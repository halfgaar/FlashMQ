<?xml version="1.0" encoding="utf-8"?>
<refentry
    xml:id="flashmq.conf"
    xml:lang="en"
    xmlns="http://docbook.org/ns/docbook"
    version="5.0"
    xmlns:xlink="http://www.w3.org/1999/xlink">

  <refmeta>
    <refentrytitle>flashmq.conf</refentrytitle>
    <manvolnum>5</manvolnum>
  </refmeta>

  <refnamediv>
    <refname>flashmq.conf</refname>
    <refpurpose>FlashMQ configuration file format</refpurpose>
  </refnamediv>

  <refsynopsisdiv xml:id="synopsis">
    <para>
      The <filename>flashmq.conf</filename> file is the configuration used for configuring the FlashMQ MQTT broker. It doesn't necessarily have to be called <filename>flashmq.conf</filename>; the <command>flashmq</command> daemon program sports a <option>--config-file</option> parameter.
    </para>
  </refsynopsisdiv>

  <refsect1 xml:id="file-format">
    <title>File format</title>
    <para>
      To set a parameter, its name must appear on a single line, followed by whitespace, followed by the parameter value.
    </para>
    <para>
      <option>parameter-name</option> <replaceable>parameter-value</replaceable>
    </para>
    <para>
      When setting boolean values, <literal>yes/no</literal>, <literal>true/false</literal> and <literal>on/off</literal> can all be used.
    </para>
    <para>
      To configure the listeners, use <option>listen</option> blocks, defined by { and }. See EXAMPLE LISTENERS for details.
    </para>
    <para>
      Lines beginning with the hash character (“<literal>#</literal>”) and empty lines are ignored. Thus, a line can be commented out by prepending a “<literal>#</literal>” to it.
    </para>
  </refsect1>

  <refsect1 xml:id="global-parameters">
    <title>Global parameters</title>
    <variablelist>
      <varlistentry xml:id="plugin">
        <term><option>plugin</option> <replaceable>/path/to/plugin.so</replaceable></term>
        <listitem>
          <para>
            FlashMQ supports an ELF shared object (<filename>.so</filename> file) plugin interface to add functionality, authorization and authentication, because it’s hard to provide a declarative mechanism that works for everybody. See <filename>flashmq_plugin.h</filename> for the API and its documentation. It’s written in C++ for ease of passing FlashMQ internals without conversion to C, but you can basically just use a C++ compiler and program like it was C; the C++ constructs are simple.
          </para>
          <para>
            FlashMQ will auto-detect which plugin interface you’re trying to load (Mosquitto version 2 or FlashMQ native). Keep in mind that each thread initializes the plugin, inline with multi-core programming (minimize shared data and interaction between threads). You could use static variables with thread synchronization if you really want to. And of course, any Mosquitto plugin that uses global and/or static variables instead of initializing memory in its <function>init()</function> method, will not be thread-safe and won’t work.
          </para>
          <para>
            You can only have one plugin active, but you can combine it with <link xlink:href="#mosquitto_password_file"><option>mosquitto_password_file</option></link> and <link xlink:href="#mosquitto_acl_file"><option>mosquitto_acl_file</option></link>. The password and ACL file take precedence, and on a ‘deny’, will not ask the plugin.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="plugin_opt_">
        <term><option>plugin_opt_*</option> <replaceable>value</replaceable></term>
        <listitem>
          <para>
            Options passed to the plugin <function>init()</function> function.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="plugin_serialize_init">
        <term><option>plugin_serialize_init</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            There could be circumstances where the plugin code is mostly thread-safe, but not on initialization. Libmysqlclient for instance, needs a one-time initialization. To add to the confusion, Qt hides that away.
          </para>
          <para>
            The plugin should preferrably be written with proper synchronization like that, but as a last resort, you can use this to synchronize initialization.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="plugin_serialize_auth_checks">
        <term><option>plugin_serialize_auth_checks</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            Like <option>plugin_serialize_init</option>, but then for all login and ACL checks.
          </para>
          <para>
            This option may be dropped at some point, because it negates much of the multi-core design. One may as well run with only one thread then.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="plugin_timer_period">
        <term><option>plugin_timer_period</option> <replaceable>seconds</replaceable></term>
        <listitem>
          <para>
            The FlashMQ auth plugin interface has a function that is called periodically this amount of seconds. This can be used to refresh state, commit data, etc.
          </para>
          <para>
            See <filename>flashmq_plugin.h</filename> for details.
          </para>
          <para>
            Default value: <literal>60</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="log_file">
        <term><option>log_file</option> <replaceable>/path/to/flashmq.log</replaceable></term>
        <listitem>
          <para>
            This configuration parameter sets the path to FlashMQ's log file. If you omit the, the output will go to stdout.
          </para>
          <para>
            Default value: <filename>/var/log/flashmq/flashmq.log</filename>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="log_level">
        <term><option>log_level</option> <replaceable>info/notice/warning/error/none</replaceable></term>
        <listitem>
          <para>
            Set the log level to specified level and above. That means <replaceable>notice</replaceable> will log <replaceable>notice</replaceable>, <replaceable>warning</replaceable> and <replaceable>error</replaceable>.
          </para>
          <para>
            Use this setting over the deprecated <option>log_debug</option> and <option>quiet</option>. If you do have those directives, they override the <option>log_level</option>, for backwards compatability reasons.
          </para>
          <para>
            Default value: <literal>info</literal>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="log_debug">
        <term><option>log_debug</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            Debug logging obviously creates a lot of log noise, so should only be done to diagnose problems.
          </para>
          <para>
              Deprecated. Use <option>log_level</option> instead.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="log_subscriptions">
        <term><option>log_subscriptions</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="allow_unsafe_clientid_chars">
        <term><option>allow_unsafe_clientid_chars</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            If you have topics with client IDs in it, people can possibly manipulate your ACL checking by saying their client ID is 'John+foobar'. Audit your security before you allow this.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="allow_unsafe_username_chars">
        <term><option>allow_unsafe_username_chars</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            If you have topics with usernames in it, people can possibly manipulate your ACL checking by saying their username is 'John+foobar'. Audit your security before you allow this.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="max_packet_size">
        <term><option>max_packet_size</option> <replaceable>bytes</replaceable></term>
        <listitem>
          <para>
            MQTT packets have a maximum size of about 256 MB. This memory will (temporarily) be allocated upon arrival of such packets, so there may be cause to set it lower.
          </para>
          <para>
            This option works in conjunction with <option>client_max_write_buffer_size</option> to limit memory use.
          </para>
          <para>
            Default value: <literal>268435461</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="client_max_write_buffer_size">
        <term><option>client_max_write_buffer_size</option> <replaceable>bytes</replaceable></term>
        <listitem>
          <para>
            The client's write buffer is where packets are stored before the event loop has the chance to flush them out. Any time a client's connection is bad and bytes can't be flushed, this buffer fills. So, there's good reason to limit this to something sensible. A good indication is your average packet size (or better yet, a configured <option>max_packet_size</option>) multiplied by the amount of packets you want to be able to buffer.
          </para>
          <para>
            Note that it's an approximate value and not a hard limit. Buffer sizes only grow by powers of two, and buffers are always allowed to grow to make place for ping packets. Additionally, upon arrival of large packets (up to <option>max_packet_size</option> bytes), room will be made up to twice their size. So, you may also want to reduce <option>max_packet_size</option> from the default.
          </para>
          <para>
            Default value is <literal>1048576</literal> (1 MB)
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="client_initial_buffer_size">
        <term><option>client_initial_buffer_size</option> <replaceable>bytes</replaceable></term>
        <listitem>
          <para>
            The buffers for reading and writing, also for websockets when relevant, start out with a particular size and double when they need to grow. If you know your clients send bulks of a particular size, it helps to set this to match, to avoid constant memory reallocation. The default value is set conservatively, for scenario's with millions of clients.
          </para>
          <para>
            After buffers have grown, they are eventually reset to their original size when possible.
          </para>
          <para>
            Also see <option>client_max_write_buffer_size</option> and <option>max_packet_size</option>.
          </para>
          <para>
            Value must be a power of two.
          </para>
          <para>
            Default value: <literal>1024</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="mosquitto_password_file">
        <term><option>mosquitto_password_file</option> <replaceable>/foo/bar/mosquitto_password_file</replaceable></term>
        <listitem>
          <para>
            File with usernames and hashed+salted passwords as generated by Mosquitto's <command>mosquitto_passwd</command>.
          </para>
          <para>
            Mosquitto up to version 1.6 uses the sha512 algorithm. Newer version use sha512-pbkdf2. Both are supported.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="mosquitto_acl_file">
        <term><option>mosquitto_acl_file</option> <replaceable>/foo/bar/mosquitto_acl_file</replaceable></term>
        <listitem>
          <para>
            ACL (access control lists) for users, anonymous users and patterns expandable with %u (username) and %c (clientid). Format is Mosquitto's acl_file.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="allow_anonymous">
        <term><option>allow_anonymous</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
              This option can be overriden on a per-listener basis; see <link xlink:href="#listen__allow_anonymous"><option>listener.allow_anonymous</option></link>.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="zero_byte_username_is_anonymous">
        <term><option>zero_byte_username_is_anonymous</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            The proper way to signal an anonymous client is by setting the 'username present' flag in the CONNECT packet to 0, which in MQTT3 also demands the absence of a password. However, there are also clients out there that set the 'username present' flag to 1 and then give an empty username. This is an undesirable situation, because it means there are two ways to identify an anonymous client.
          </para>

          <para>
            Anonymous clients are not authenticated against a loaded plugin when <option>allow_anonymous</option> is true. With this option enabled, that means users with empty string as usernames also aren't.
          </para>

          <para>
            With this option disabled, clients connecting with an empty username will be reject with 'bad username or password' as MQTT error code.
          </para>

          <para>
            The default is to be unambigious, but this can be overridden with this option.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="rlimit_nofile">
        <term><option>rlimit_nofile</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            The general Linux default of <literal>1024</literal> can be overridden. Note: <systemitem class="daemon">systemd</systemitem> blocks you from setting it, so it needs to be set on the unit. The default systemd unit file sets <option>LimitNOFILE=infinity</option>. You may also need to set <option>sysctl -w fs.file-max=10000000</option>
          </para>
          <para>
            Default value: <literal>1000000</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="expire_sessions_after_seconds">
        <term><option>expire_sessions_after_seconds</option> <replaceable>seconds</replaceable></term>
        <listitem>
          <para>
            Expire sessions after this time. Setting to 0 disables it and is (MQTT3) standard-compliant. But, existing sessions cause load on the server (because they cost memory and are still subscribers), so keeping sessions after any client that connects with a random ID doesn't make sense.
          </para>
          <para>
            Default value: <literal>1209600</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="quiet">
        <term><option>quiet</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            Don't log LOG_INFO and LOG_NOTICE. This is useful when you have a lot of foot traffic, because otherwise the log gets filled with connect/disconnect notices.
          </para>
          <para>
              Deprecated. Use <option>log_level</option> instead.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="storage_dir">
        <term><option>storage_dir</option> <replaceable>/path/to/dir</replaceable></term>
        <listitem>
          <para>
            Location to store sessions, subscriptions and retained messages.
            Not specifying this will turn off persistence.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term xml:id="max_qos_msg_pending_per_client"><option>max_qos_msg_pending_per_client</option></term>
        <term xml:id="max_qos_bytes_pending_per_client"><option>max_qos_bytes_pending_per_client</option></term>
        <listitem>
          <para>
            There is a limit to how many QoS packets can be stored in a session, so you can define a maximum amount of messages and bytes. If any of these is exceeded, the packet is dropped.
          </para>
          <para>
            Defaults:
          </para>
          <itemizedlist>
            <listitem>
              <para>max_qos_msg_pending_per_client 512</para>
            </listitem>
            <listitem>
              <para>max_qos_bytes_pending_per_client 65536</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="max_incoming_topic_alias_value">
        <term><option>max_incoming_topic_alias_value</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            Is communicated towards MQTT5 clients. It is then up to them to decide to set them or not.
          </para>
          <para>
            Changing this setting and reloading the config only has effect on new clients, because existing clients would otherwise exceed the limit they think applies.
          </para>
          <para>
            Default value: <literal>65535</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="max_outgoing_topic_alias_value">
        <term><option>max_outgoing_topic_alias_value</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            FlashMQ will make this many aliases per MQTT5 client, if they ask for aliases (with the connect property <option>TopicAliasMaximum</option>).
          </para>
          <para>
            Default value: <literal>65535</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="thread_count">
        <term><option>thread_count</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            If you want to have a different amount of worker threads then CPUs, you can set this value. Typically you don't need to set this.
          </para>
          <para>
            Default value: <filename>auto-detect</filename>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="wills_enabled">
        <term><option>wills_enabled</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            When disabled, the server will not set last will and testament specified by connecting clients.
          </para>
          <para>
            Default value: <filename>true</filename>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="retained_messages_mode">
        <term><option>retained_messages_mode</option> <replaceable>enabled/downgrade/drop/disconnect_with_error</replaceable></term>
        <listitem>
          <para>
            Retained messages can be a strain on the server you may not need. You can set various ways of dealing with them:
          </para>
          <para>
            <filename>enabled</filename>. This is normal operation.
          </para>
          <para>
            <filename>downgrade</filename>. The retain flag is removed and treated like a normal publish.
          </para>
          <para>
            <filename>drop</filename>. Messages with retain set are dropped.
          </para>
          <para>
            <filename>disconnect_with_error</filename>. Disconnect clients who try to set them.
          </para>
          <para>
            Default value: <filename>enabled</filename>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="expire_retained_messages_after_seconds">
        <term><option>expire_retained_messages_after_seconds</option> <replaceable>seconds</replaceable></term>
        <listitem>
          <para>
            Use this to limit the life time of retained messages. Without this, the amount of retained messages may never decrease.
          </para>
          <para>
            Default value: <filename>4294967296</filename>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="retained_messages_delivery_limit">
        <term><option>retained_messages_delivery_limit</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            Deprecated.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="retained_messages_node_limit">
        <term><option>retained_messages_node_limit</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            When clients place a subscription, they will get the retained messages matching that subscription. Even though traversing the retained message tree is deprioritized in favor of other traffic, it will still cause CPU load until it's done. If you have a tree with millions of nodes and clients subscribe to `#`, this is potentially unwanted. You can use this setting to limit how many nodes of the retrained tree are traversed. 
          </para>
          <para>
            Note that the topic `one/two/three` is three nodes, and each node doesn't necessarilly need to contain a message.
          </para>
          <para>
            Default value: <filename>4294967296</filename>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="websocket_set_real_ip_from">
        <term><option>websocket_set_real_ip_from</option> <replaceable>inet4_address/inet6_address</replaceable></term>
        <listitem>
          <para>
              HTTP proxies in front of the websocket listeners can set the <replaceable>X-Real-IP</replaceable> header to identify the original connecting client. With <option>websocket_set_real_ip_from</option> you can mark IP networks as trusted. By default, clients are not trusted, to avoid spoofing.
          </para>
          <para>
              You can repeat the option to allow for multiple addresses. Valid notations are <replaceable>1.2.3.4</replaceable>, <replaceable>1.2.3.4/16</replaceable>, <replaceable>1.2.0.0/16</replaceable>, <replaceable>2a01:1337::1</replaceable>, <replaceable>2a01:1337::1/64</replaceable>, etc.
          </para>
          <para>
              The header <replaceable>X-Forwarded-For</replaceable> is not used, because that's designed to contain a list of addresses, if applicable.
          </para>
          <para>
            As a side note about using a proxy on your listener; you can only have an absolute max of 65535 connections to an IP+port combination (and the practical limit is lower). If you need more, you have to set up multiple listeners. This can be multiple IP addresses, or simply multiple ports.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="shared_subscription_targeting">
        <term><option>shared_subscription_targeting</option> <replaceable>round_robin/sender_hash</replaceable></term>
        <listitem>
          <para>
            When having multiple subscribers on a shared subscription (like '$share/myshare/jane/doe'), select how the messages should be distributed over the subscribers.
          </para>
          <para>
            <replaceable>round_robin</replaceable>. Select the next subscriber for each message. There is still some amount of randomness to it because the counter for this is not thread safe. Using an atomic/mutexed counter for it would just be too slow to justify.
          </para>
          <para>
            <replaceable>sender_hash</replaceable>. Selects a receiver deterministically based on the hash of the client ID of the sender. The selected subscriber will depend on how many subscribers there are, so if some disconnect, the distribution will change. Moreover, the selection may also change when FlashMQ cleans up empty spaces in the list of shared subscribers.
          </para>
          <para>
            Default: <replaceable>round_robin</replaceable>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="minimum_wildcard_subscription_depth">
        <term><option>minimum_wildcard_subscription_depth</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            Defines the minimum level of the first wildcard topic filter (<option>#</option> and <option>+</option>). In a topic filter like <option>sensors/temperature/#</option>, that is 2. If you specify 2, a subscription to <option>sensors/#</option> will be denied. Remember that only MQTT 3.1.1 and newer actually notify the client of the denial in the sub-ack packet.
          </para>
          <para>
            The reason you may want to limit it, is performance. If you have a base message load of 100,000 messages per second, each client subscribing to <option>#</option> causes that many permission checks per second. If you have 100 clients doing that, there will be 10 million permission checks per second.
          </para>
          <para>
            Default: <replaceable>0</replaceable>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="wildcard_subscription_deny_mode">
        <term><option>wildcard_subscription_deny_mode</option> <replaceable>deny_all/deny_retained_only</replaceable></term>
        <listitem>
          <para>
            For <option>minimum_wildcard_subscription_depth</option>, specify what you want to deny. Trying to give a client all retained messages can cause quite some load, so only denying the retained messages upon receiving a broad wildcard subscription can be useful if you have a low enough general message volume, but a high number of retained messages. 
          </para>
          <para>
            Default: <literal>deny_all</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="include_dir">
        <term><option>include_dir</option> <replaceable>/path/to/dir</replaceable></term>
        <listitem>
          <para>
            Load *.conf files from the specified directory, to merge with the main configuration file.
          </para>
          <para>
            An error is generated when the directory is not there. This is to protect against running incorrect configurations by accident, when the dir has been renamed, for example.
          </para>
        </listitem>
      </varlistentry>

    </variablelist>
  </refsect1>

  <refsect1>
    <title>Listen parameters</title>
    <para>
       Listen parameters can only be used within <literal>listen { }</literal> blocks.
    </para>
    <variablelist>
      <varlistentry xml:id="port">
        <term><option>port</option></term>
        <listitem>
          <para>
            The default port depends on the <option>protocol</option> parameter and whether or not <option>fullchain</option> and <option>privkey</option> parameters are supplied:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                  For unencrypted MQTT, the default port is <literal>1883</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                  For encrypted MQTT, the default port is <literal>8883</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                  For plain HTTP websockets, the default port is <literal>8080</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                  For encrypted HTTPS websockets, the default port is <literal>4443</literal>
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="protocol">
        <term><option>protocol</option></term>
        <listitem>
          <para>
            Valid values:
            <simplelist type="horiz">
              <member>
                <literal>mqtt</literal>
              </member>
               <member>
                <literal>websockets</literal>
              </member>
            </simplelist>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="inet_protocol">
        <term><option>inet_protocol</option></term>
        <listitem>
          <para>
            Valid values:
            <simplelist type="horiz">
              <member>
                <literal>ip4_ip6</literal>
              </member>
              <member>
                <literal>ip4</literal>
              </member>
              <member>
                <literal>ip6</literal>
              </member>
            </simplelist>
            <para>
              Default: ip4_ip6
            </para>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="inet4_bind_address">
        <term><option>inet4_bind_address</option> <replaceable>inet4address</replaceable></term>
        <listitem>
          <para>
            Default: 0.0.0.0
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="inet6_bind_address">
        <term><option>inet6_bind_address</option> <replaceable>inet6address</replaceable></term>
        <listitem>
          <para>
            Default: ::0
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="fullchain">
        <term><option>fullchain</option> <replaceable>/foobar/server.crt</replaceable></term>
        <listitem>
          <para>
            Specifying a chain makes the listener SSL, and also requires the <option>privkey</option> to be set.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry xml:id="privkey">
        <term><option>privkey</option> <replaceable>/foobar/server.key</replaceable></term>
        <listitem>
          <para>
            Specifying a private key makes the listener SSL, and also requires the <option>fullchain</option> to be set.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="client_verification_ca_file">
        <term><option>client_verification_ca_file</option> <replaceable>/foobar/client_authority.crt</replaceable></term>
        <listitem>
          <para>
            Clients can be authenticated using X509 certificates, and the username taken from the CN (common name) field. Use this directive to specify the certificate authority you trust.
          </para>
          <para>
            Specifying this or <option>client_verification_ca_dir</option> will require the listener to be TLS.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="client_verification_ca_dir">
        <term><option>client_verification_ca_dir</option> <replaceable>/foobar/dir_with_certificates</replaceable></term>
        <listitem>
          <para>
            Clients can be authenticated using X509 certificates, and the username taken from the CN (common name) field. Use this directive to specify the dir containing certificate authorities you trust.
          </para>
          <para>
              Note that the filename requirements are dictated by OpenSSL. Use the utility <command>openssl rehash /path/to/dir</command>.
          </para>
          <para>
            Specifying this or <option>client_verification_ca_file</option> will require the listener to be TLS.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="client_verification_still_do_authn">
        <term><option>client_verification_still_do_authn</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            When using X509 client authentication with <option>client_verification_ca_file</option> or <option>client_verification_ca_dir</option>, the username will not be checked with a user database or a plugin by default. Set this option to <literal>true</literal> to override that.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="listen__allow_anonymous">
        <term><option>allow_anonymous</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            This allows you to override the <link xlink:href="#allow_anonymous">global <option>allow_anonymous</option></link> setting on the listener level.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="haproxy">
        <term><option>haproxy</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            Setting the listener to haproxy makes it expect the PROXY protocol and set client source address to the original client. Make sure this listener is private / firewalled, otherwise anybody can set a different source address.
          </para>
          <para>
            Note that HAProxy's server health checks only started using the 'local' specifier as of version 2.4. This means earlier version will pretend to be a client and break the connection, causing log spam.
          </para>
          <para>
            As a side note about using a proxy on your listener; you can only have an absolute max of 65535 connections to an IP+port combination (and the practical limit is lower). If you need more, you have to set up multiple listeners. This can be multiple IP addresses, or simply multiple ports.
          </para>
          <para>
            See <link xlink:href="http://www.haproxy.org/">haproxy.org</link>.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1 xml:id="example_config">
    <title>Example listeners</title>

    <literallayout class="monospaced"><![CDATA[listen {
  protocol mqtt
  inet_protocol ip4_ip6
  inet4_bind_address 127.0.0.1
  inet6_bind_address ::1
  fullchain /foobar/server.crt
  privkey /foobar/server.key

  # default = 8883
  port 8883
}
listen {
  protocol mqtt
  fullchain /foobar/server.crt
  privkey /foobar/server.key
  client_verification_ca_file /foobar/client_authority.crt
  client_verification_still_do_authn false
}
listen {
  protocol mqtt
  inet_protocol ip4

  # default = 1883
  port 1883
}
listen {
  protocol websockets
  fullchain /foobar/server.crt
  privkey /foobar/server.key

  # default = 4443
  port 4443
}
listen {
  protocol websockets

  # default = 8080
  port 8080
}
listen {
  port 2883
  haproxy on
}]]></literallayout>
  </refsect1>

  <refsect1 xml:id="bridge">
    <title>Bridge configuration</title>
    <para>
       Bridges can be defined inside <literal>bridge { }</literal> blocks. A bridge is essentially just an outgoing connection to another server with loop-detection and retain flag relaying. It is not a form of clustering. Also note that one bridge is one connection, and because FlashMQ's threading model is that clients are serviced by one selected thread only, a bridge has the potential to saturate a thread, if it's heavily loaded. You could work around that by defining multiple bridges to the same server, for various topic paths. A future version of FlashMQ will likely improve upon this.
    </para>

    <variablelist>
      <varlistentry xml:id="bridge__address">
        <term><option>address</option> <replaceable>address</replaceable></term>
        <listitem>
          <para>
              The DNS name, IPv4 or IPv6 address of the server you want to connect to.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__port">
        <term><option>port</option> <replaceable>number</replaceable></term>
        <listitem>
          <para>
            The default port depends on the <option>tls</option> option, either 1883 or 8883.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__inet_protocol">
        <term><option>inet_protocol</option> <replaceable>ip4_ip6/ip4/ip6</replaceable></term>
        <listitem>
          <para>
            Default: <literal>ip4_ip6</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__tls">
        <term><option>tls</option> <replaceable>off/on/unverified</replaceable></term>
        <listitem>
          <para>
            Set TLS mode. The value <option>unverified</option> means the x509 chain is not verified.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__ca_file">
        <term><option>ca_file</option> <replaceable>path</replaceable></term>
        <listitem>
          <para>
            File to be used for x509 certificate chain validation.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__ca_dir">
        <term><option>ca_dir</option> <replaceable>path</replaceable></term>
        <listitem>
          <para>
            Directory containing certificates for x509 certificate chain validation.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__protocol_version">
        <term><option>protocol_version</option> <replaceable>mqtt3.1/mqtt3.1.1/mqtt5</replaceable></term>
        <listitem>
          <para>
            Default: <literal>mqtt3.1.1</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__bridge_protocol_bit">
        <term><option>bridge_protocol_bit</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            An unofficial standard is to set the most significant bit of the protocol version byte to 1 to signal the connection is a bridge. This allows the other side to alter its behavior slightly. However, this is not always supported, so you can disable this if you get disconnected for reporting an invalid protocol version.
          </para>
          <para>
            This setting has no effect when using MQTT5, because the behavior it influences is done with subscription options.
          </para>
          <para>
            Default: <literal>true</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__keepalive">
        <term><option>keepalive</option> <replaceable>seconds</replaceable></term>
        <listitem>
          <para>
            The time between sending ping packets to the other side.
          </para>
          <para>
            Default: <literal>60</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__clientid_prefix">
        <term><option>clientid_prefix</option> <replaceable>prefix</replaceable></term>
        <listitem>
          <para>
            The prefix of the randomly generated client ID. Client IDs cannot be explicitely set for security reasons. See <link xlink:href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">Understanding clean session and clean start</link>.
          </para>
          <para>
            Default: <literal>fmqbridge</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__publish">
        <term><option>publish</option> <replaceable>filter</replaceable> <replaceable>qos</replaceable></term>
        <listitem>
          <para>
              Messages matching this filter will be published to the other side. Examples: <literal>#</literal> or <literal>sport/tennis/#</literal>. This option can be repeated several times.
          </para>
          <para>
            The QoS value should be seen as the QoS value of the internal subscription causing outgoing messages. Messages that are relayed have this QoS level at most.
          </para>
          <para>
              Default: <literal>0</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__subscribe">
        <term><option>subscribe</option> <replaceable>filter</replaceable> <replaceable>qos</replaceable></term>
        <listitem>
          <para>
              Subscriptions for this filter is placed at the other side. Examples: <literal>#</literal> or <literal>sport/tennis/#</literal>. This option can be repeated several times.
          </para>
          <para>
            The QoS value is like any subscription at a server. Messages received by the other end will be given this QoS level at most.
          </para>
          <para>
              Default: <literal>0</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__local_username">
        <term><option>local_username</option> <replaceable>username</replaceable></term>
        <listitem>
          <para>
            Username as seen by the local FlashMQ's plugin or ACL checks. This is not always necessary.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__remote_username">
        <term><option>remote_username</option> <replaceable>username</replaceable></term>
        <listitem>
          <para>
            Username sent to the remote connection.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__remote_password">
        <term><option>remote_password</option> <replaceable>password</replaceable></term>
        <listitem>
          <para>
            Password sent to the remote connection.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__remote_clean_start">
        <term><option>remote_clean_start</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
            In MQTT3, this means 'clean session', meaning the remote server removes any existing session with the same ID on (re)connect, and destroys it immediately on disconnect. If you want reuseable sessions that survive disconnects, set this to false. If you also want to pick up remote sessions on FlashMQ restart, set <option>use_saved_clientid</option> to true.
          </para>
          <para>
            In MQTT5, this option only influences reconnection behavior. It essentially has no effect on the first connect, because the client ID is random and will always be new (except when you set <option>use_saved_clientid</option>). But when set to true, any reconnects, which do use the already generated client ID, will destroy the session and in-flight messages will be lost.
          </para>
          <para>
            Also see <link xlink:href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">understanding clean session and clean start</link>.
          </para>
          <para>
            Default value: <literal>true</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__local_clean_start">
        <term><option>local_clean_start</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
              In MQTT3 mode, this means 'clean session' and means the session is removed upon disconnect. If you want to reuse sessions on reconnect, set this to false. Any new start of FlashMQ will give you a new client ID so will always be a fresh session, except if you set <option>use_saved_clientid</option>.
          </para>
          <para>
            In MQTT5 mode, this has no effect. If you want the session to be removed immediately on disconnect, use <option>local_session_expiry_interval</option> to 0.
          </para>
          <para>
            Also see <link xlink:href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">understanding clean session and clean start</link>.
          </para>
          <para>
            Default value: <literal>true</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__remote_session_expiry_interval">
        <term><option>remote_session_expiry_interval</option> <replaceable>seconds</replaceable></term>
        <listitem>
          <para>
            Is only used in MQTT5 mode and determines the amount of seconds after which the session can be removed from the remote server.
          </para>
          <para>
            Default value: <literal>0</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__local_session_expiry_interval">
        <term><option>local_session_expiry_interval</option> <replaceable>seconds</replaceable></term>
        <listitem>
          <para>
              Determines when a local session without an active client will be removed, in both MQTT3 and MQTT5 mode. Note that in MQTT3 mode, the session is removed on disconnect when <option>local_clean_start</option> is true.
          </para>
          <para>
            Default value: <literal>0</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__remote_retain_available">
        <term><option>remote_retain_available</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
              MQTT5 allows a server to tell a client it doesn't support retained messages, or has it disabled. When using MQTT3, use this option to achieve the same.
          </para>
          <para>
              Messages will not be relayed with 'retained as published' and the retained messages that are normally sent on matching subscription, are not sent.
          </para>
          <para>
            Default value: <literal>true</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__use_saved_clientid">
        <term><option>use_saved_clientid</option> <replaceable>true/false</replaceable></term>
        <listitem>
          <para>
              When you want your bridges to resume local and remote sessions after restart, set this to true and set <option>remote_clean_start</option>, <option>local_clean_start</option>, <option>remote_session_expiry_interval</option> and <option>local_session_expiry_interval</option> accordingly. It only has effect when you have set a <option>storage_dir</option>.
          </para>
          <para>
              It is important to fully understand the clean session / clean start behavior and the role the client ID plays in that. The primary goal of sessions is to survive link disconnects. Configuring a fixed client ID and use that each time an MQTT client starts, is often an anti-pattern, because most clients like actual IoT devices start fresh upon restart and don't store their sessions (with in-flight packets, etc) to disk. FlashMQ does store it on disk however, so it can be used legitamately. However, you can run into unexpected situations. For instance, you will get your existing subscriptions from the session too. So, if you remove a <option>subscribe</option> line from your bridge configuration and restart, it will actually have no effect, because the server on the other side still has that subscription in the session.
          </para>
          <para>
            See <link xlink:href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">understanding clean session and clean start</link> for details.
          </para>
          <para>
            Default value: <literal>false</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__max_outgoing_topic_aliases">
        <term><option>max_outgoing_topic_aliases</option> <replaceable>amount</replaceable></term>
        <listitem>
          <para>
            If you want FlashMQ to initiate topic aliases for this bridge, set this to a non-zero value. Note that it's floored to the value the remote side gives in the CONNACK packet, so it only works if the other side permits it.
          </para>
          <para>
              Default: <literal>0</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry xml:id="bridge__max_incoming_topic_aliases">
        <term><option>max_incoming_topic_aliases</option> <replaceable>amount</replaceable></term>
        <listitem>
          <para>
            If you want to accept topic aliases for this bridge, set this to a non-zero value. The value is set in the CONNECT packet to inform the remote side of the wish. It's not guaranteed that the other side will actually make aliases.
          </para>
          <para>
              Default: <literal>0</literal>
          </para>
        </listitem>
      </varlistentry>

    </variablelist>
  </refsect1>

  <refsect1 xml:id="example_bridge">
    <title>Example bridge</title>

    <literallayout class="monospaced"><![CDATA[bridge {
    address demo.flashmq.org
    publish send/this
    subscribe receive/this
    local_username my_local_user
    remote_username my_remote_user
    remote_password my_remote_pass
    bridge_protocol_bit false
    tls on
    ca_file /path/to/ca.crt
}]]></literallayout>
  </refsect1>

  <refsect1>
    <title>Author</title>
    <para>
        Wiebe Cazemier <email>contact@flashmq.org</email>.
    </para>
  </refsect1>

  <refsect1>
    <title>See also</title>

    <para>
      <simplelist type="inline">
        <member>
          <citerefentry>
            <refentrytitle>flashmq</refentrytitle>
            <manvolnum>1</manvolnum>
          </citerefentry>
        </member>
      </simplelist>
    </para>
    <para>
      <link xlink:href="https://www.flashmq.org/">www.flashmq.org</link>
    </para>
  </refsect1>
</refentry>
<!-- vim: set expandtab ft=xml shiftwidth=2 tabstop=2: -->
