<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" data-color-scheme="light" data-fallback-color-scheme="light" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>flashmq.conf (5) – FlashMQ configuration file format</title><style type="text/css" media="screen">
        html[data-color-scheme=light] {
          --bgcolor: #fff;
          --pre-bgcolor: #ddd;
          --pre-color: #000;
          --main-color: #000;
          --h1-color: #111;
          --h2-color: #111;
          --h3-color: #111;
          --dt-color: #111;
          --link-color: blue;
          --vlink-color: purple;
          --alink-color: red;
          --hash-color: #aaa;
          --hash-hover-color: #111;
          --code-bgcolor: transparent;
        }
        html[data-color-scheme=dark] {
          --bgcolor: #111;
          --pre-bgcolor: #000;
          --pre-color: lightgrey;
          --main-color: lightgrey;
          --h1-color: lightgrey;
          --h2-color: lightgrey;
          --h3-color: lightgrey;
          --dt-color: lightgrey;
          --link-color: lightblue;
          --vlink-color: lightpink;
          --alink-color: lightcoral;
          --hash-color: grey;
          --hash-hover-color: #fff;
          --code-bgcolor: transparent;
        }
        html {
          margin: 0;
          padding: 0;
          font-size: 18px;  /* Set rem */
          font-family: sans-serif;
          background-color: var(--bgcolor);
          color: var(--main-color);
        }
        body {
          padding: 1rem 2rem;
          line-height: 1.5em;
        }
        article {
          box-sizing: border-box;
          max-width: 50em;
          padding-left: 3rem;
        }
        header {
          margin-top: 2.5rem;
          margin-bottom: -.25rem;
          margin-left: -3rem;
        }
        h1 {
          margin: 0;
          line-height: 1.2em;
          font-size: 2rem;
          font-weight: bold;
          color: var(--h1-color);
        }
        h1 code.manvolnum {
          font-size: 70%;
        }
        h2.refpurpose {
          margin-top: -.25em;
          font-size: 1em;
          text-transform: none;
        }
        h2 {
          margin: 0;
          line-height: 1.2em;
          font-size: .9rem;
          font-weight: 600;
          color: var(--h2-color);
          text-transform: uppercase;
        }
        dt {
          margin-bottom: -.5rem;
          font-weight: bold;
          color: var(--dt-color);
        }
        dt .replaceable {
          text-decoration: underline;
          font-weight: normal;
        }
        dd {
          margin-bottom: 2em;
        }
        a:link {
          color: var(--link-color);
        }
        a:visited {
          color: var(--vlink-color);
        }
        a.hash-anchor {
          margin-left: .5em;
          color: var(--hash-color);
          text-decoration: none;
          font-weight: normal;
        }
        a.hash-anchor:hover {
          text-decoration: underline;
          color: var(--hash-hover-color);
        }
        code {
          background-color: var(--code-bgcolor);
          font-family: monospace;
          font-weight: bold;
        }
        pre.monospaced, pre.cmdsynopsis {
          background-color: var(--pre-bgcolor);
          padding: 2em 2em;
          color: var(--pre-color);
          font-family: monospace;
        }

        .color-scheme-switch {
          position: fixed;
          top: 0;
          right: 0;

          input {
            display: none;
          }
          label {
            margin: 0;
            box-sizing: border-box;
            display: inline-block;
            position: relative;
            height: 32px;
            width: 32px;
            font-size: 20px;
            padding: 6px;
            line-height: 20px;
            cursor: pointer;
            text-align: center;
          }
          input[value=""] + label {
            background-color: transparent;
            color: var(--main-color);
          }
          input[value=light] + label {
            background-color: white;
            color: black;
          }
          input[value=dark] + label {
            background-color: black;
            color: white;
          }
          input:checked + label::before {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 12px;
            width: 6px;
            height: 6px;
            border: 2px solid black;
            border-radius: 50%;
            background-color: white;
          }
        }
      </style><style xmlns="http://docbook.org/ns/docbook" xmlns:dbk="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:semver="https://semver.org/spec/v2.0.0.html" xmlns:fmq="http://www.flashmq.org/man/" type="text/css" media="screen">
        html[data-color-scheme=light] {
          --compatible-flashmq-version-color: #209020;
          --incompatible-flashmq-version-color: crimson;
          --flashmq-version-weight: bold;
        }
        html[data-color-scheme=dark] {
          --compatible-flashmq-version-color: #5cdd5c;
          --incompatible-flashmq-version-color: #fd5c5c;
          --flashmq-version-weight: normal;
        }

        .flashmq_version_requirement {
          float: right;
          color: var(--main-color);
          font-size: .9rem;
          font-weight: var(--flashmq-version-weight);

          &.compatible-with-selected-flashmq-version {
            color: var(--compatible-flashmq-version-color);
          }
          &.incompatible-with-selected-flashmq-version {
            color: var(--incompatible-flashmq-version-color);
          }
        }

        #flashmq-version-nav {
          position: sticky;
          top: 0;
        }

        #select-flashmq-version {
          float: right;
          margin-top: 4px;
          padding: 4px;
          font-size: .8rem;
        }
      </style></head><body><nav class="color-scheme-switch" hidden="true"><input type="radio" id="color-scheme-browser-default" checked name="color-scheme" value=""></input><label for="color-scheme-browser-default" title="Follow browser default">A</label><input type="radio" id="color-scheme-light" name="color-scheme" value="light"></input><label for="color-scheme-light" title="Change to light theme">☀</label><input type="radio" id="color-scheme-dark" name="color-scheme" value="dark"></input><label for="color-scheme-dark" title="Change to dark theme">⏾</label></nav><script>
      function setColorScheme(colorScheme) {
        if (!colorScheme) {
          localStorage.removeItem('colorScheme');
        }
        else {
          localStorage.setItem('colorScheme', colorScheme);
        }

        document.querySelector('html').dataset.colorScheme = getColorScheme();
      }

      function getColorScheme() {
        const localValue = localStorage.getItem('colorScheme');
        if (localValue !== null) {
          return localValue;
        }

        const browserValue = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        if (browserValue !== null) {
          return browserValue;
        }

        return document.querySelector('html').dataset.fallbackColorScheme;
      }

      document.querySelectorAll('.color-scheme-switch').forEach(el => {
        el.hidden = false;

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          document.querySelector('html').dataset.colorScheme = getColorScheme();
        });

        el.querySelectorAll('input').forEach(input => {
          if (input.checked) {
            setColorScheme(input.value);
          }
          input.addEventListener('change', (event) => {
            setColorScheme(event.target.value);
          });
        });
      });
      </script><article id="flashmq.conf.5"><nav xmlns="http://docbook.org/ns/docbook" xmlns:dbk="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:semver="https://semver.org/spec/v2.0.0.html" xmlns:fmq="http://www.flashmq.org/man/" id="flashmq-version-nav"><select id="select-flashmq-version"><option value="" selected>latest</option><option value="1.23.0">≥ v1.23.0</option><option value="1.22.0">≥ v1.22.0</option><option value="1.21.0">≥ v1.21.0</option><option value="1.20.0">≥ v1.20.0</option><option value="1.19.0">≥ v1.19.0</option><option value="1.18.0">≥ v1.18.0</option><option value="1.16.0">≥ v1.16.0</option><option value="1.15.1">≥ v1.15.1</option><option value="1.14.0">≥ v1.14.0</option><option value="1.13.0">≥ v1.13.0</option><option value="1.12.0">≥ v1.12.0</option><option value="1.11.0">≥ v1.11.0</option><option value="1.10.0">≥ v1.10.0</option><option value="1.9.0">≥ v1.9.0</option><option value="1.8.4">≥ v1.8.4</option><option value="1.8.0">≥ v1.8.0</option><option value="1.7.0">≥ v1.7.0</option><option value="1.6.7">≥ v1.6.7</option><option value="1.4.4">≥ v1.4.4</option><option value="1.4.2">≥ v1.4.2</option><option value="1.2.0">≥ v1.2.0</option><option value="1.1.0">≥ v1.1.0</option></select></nav><header><h1>flashmq.conf<code class="manvolnum"> (5)</code></h1><h2 class="refpurpose">FlashMQ configuration file format</h2></header><section class="refsynopsisdiv" id="synopsis"><header><h2>Synopsis</h2></header>
    <p>
       The <code class="filename">flashmq.conf</code> file is the configuration used for configuring the FlashMQ MQTT broker.
    </p>
  </section><section class="refsect1" id="config-location">
    <header><h2>Config location<a class="hash-anchor" href="#config-location">#</a></h2></header>
    <p>
      By default, the <code class="command">flashmq</code> daemon expects to find its configuration file at <code class="filename">/etc/flashmq/flashmq.conf</code>, but this can be overriden using the <code class="option">--config-file</code> command-line argument; see the <a href="https://www.flashmq.org/man/flashmq.1"><cite class="citerefentry"><span class="refentrytitle">flashmq</span><span class="manvolnum">(1)</span></cite></a> man page for details.
    </p>
    <p>
      Using the <a href="#include_dir"><code class="option">include_dir</code></a> parameter in your config file, you can load all the <code class="filename">*.conf</code> files from that given directory.
    </p>
  </section><section class="refsect1" id="file-format">
    <header><h2>File format<a class="hash-anchor" href="#file-format">#</a></h2></header>
    <p>
      To set a parameter, its name must appear on a single line, followed by one or more potentially quoted arguments.
    </p>

    <pre class="literallayout monospaced">parameter-name1 parameter-value
parameter-name2 'value with spaces'
parameter-name3 "escaped \" quote"
multi-value-param one 'two' "three" "with ' char"
      </pre>

    <p>
      Quoted values are the same as unquoted values when they don't need it. They are necessary for when argument values have spaces, for instance.
    </p>
    <p>
      When setting boolean values, <code class="literal">yes</code>/<code class="literal">no</code>, <code class="literal">true</code>/<code class="literal">false</code> and <code class="literal">on</code>/<code class="literal">off</code> can all be used.
    </p>
    <p>
      To configure the listeners, use <code class="option">listen</code> blocks, defined by <code class="literal">{</code> and <code class="literal">}</code>. See <a href="#example_listeners">EXAMPLE LISTENERS</a> for details.
    </p>
    <p>
      Lines beginning with the hash character (“<code class="literal">#</code>”) and empty lines are ignored. Thus, a line can be commented out by prepending a “<code class="literal">#</code>” to it.
    </p>
  </section><section class="refsect1" id="global-parameters">
    <header><h2>Global parameters<a class="hash-anchor" href="#global-parameters">#</a></h2></header>
    <dl>
      
        <dt id="plugin"><code class="option">plugin</code> <code class="filename">/path/to/plugin.so</code><a class="hash-anchor" href="#plugin">#</a></dt>
        <dd>
          <p>
            FlashMQ supports an ELF shared object (<code class="filename">.so</code> file) plugin interface to add functionality, authorization and authentication, because it’s hard to provide a declarative mechanism that works for everybody. See <code class="filename">flashmq_plugin.h</code> for the API and its documentation. It’s written in C++ for ease of passing FlashMQ internals without conversion to C, but you can basically just use a C++ compiler and program like it was C; the C++ constructs are simple.
          </p>
          <p>
            FlashMQ will auto-detect which plugin interface you’re trying to load (Mosquitto version 2 or FlashMQ native). Keep in mind that each thread initializes the plugin, inline with multi-core programming (minimize shared data and interaction between threads). You could use static variables with thread synchronization if you really want to. And of course, any Mosquitto plugin that uses global and/or static variables instead of initializing memory in its <code class="function">init()</code> method, will not be thread-safe and won’t work.
          </p>
          <p>
            You can only have one plugin active, but you can combine it with <a href="#mosquitto_password_file"><code class="option">mosquitto_password_file</code></a> and <a href="#mosquitto_acl_file"><code class="option">mosquitto_acl_file</code></a>. The password and ACL file take precedence, and on a ‘deny’, will not ask the plugin.
          </p>
        </dd>
      

      
        <dt id="plugin_opt_"><code class="option">plugin_opt_*</code> <code class="replaceable">value</code><a class="hash-anchor" href="#plugin_opt_">#</a></dt>
        <dd>
          <p>
            Options passed to the plugin <code class="function">init()</code> function.
          </p>
        </dd>
      

      
        <dt id="plugin_serialize_init"><code class="option">plugin_serialize_init</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#plugin_serialize_init">#</a></dt>
        <dd>
          <p>
            There could be circumstances where the plugin code is mostly thread-safe, but not on initialization. Libmysqlclient for instance, needs a one-time initialization. To add to the confusion, Qt hides that away.
          </p>
          <p>
            The plugin should preferrably be written with proper synchronization like that, but as a last resort, you can use this to synchronize initialization.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="plugin_serialize_auth_checks"><code class="option">plugin_serialize_auth_checks</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#plugin_serialize_auth_checks">#</a></dt>
        <dd>
          <p>
            Like <code class="option">plugin_serialize_init</code>, but then for all login and ACL checks.
          </p>
          <p>
            This option may be dropped at some point, because it negates much of the multi-core design. One may as well run with only one thread then.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="plugin_timer_period"><code class="option">plugin_timer_period</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#plugin_timer_period">#</a></dt>
        <dd>
          <p>
            The FlashMQ auth plugin interface has an optional function that is called periodically this amount of seconds. This can be used to refresh state, commit data, etc.
          </p>
          <p>
            Setting a value of 0 disables it. You can enable and disable this timer with a config reload.
          </p>
          <p>
            See <code class="filename">flashmq_plugin.h</code> for details.
          </p>
          <p>
            Default value: <code class="literal">60</code>
          </p>
        </dd>
      
      
        <dt id="log_file"><code class="option">log_file</code> <code class="filename">/path/to/flashmq.log</code><a class="hash-anchor" href="#log_file">#</a></dt>
        <dd>
          <p>
            This configuration parameter sets the path to FlashMQ's log file. If you omit this option from the config file, the output will go to stdout.
          </p>
        </dd>
      
      
        <dt id="log_level"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.11.0">≥ v1.11.0</div><code class="option">log_level</code> <code class="replaceable">debug</code>|<code class="replaceable">info</code>|<code class="replaceable">notice</code>|<code class="replaceable">warning</code>|<code class="replaceable">error</code>|<code class="replaceable">none</code><a class="hash-anchor" href="#log_level">#</a></dt>
        <dd>
          <p>
            Set the log level to specified level and above. That means <code class="replaceable">notice</code> will log <code class="replaceable">notice</code>, <code class="replaceable">warning</code> and <code class="replaceable">error</code>.
          </p>
          <p>
            Use this setting over the deprecated <code class="option">log_debug</code> and <code class="option">quiet</code>. If you do have those directives, they override the <code class="option">log_level</code>, for backwards compatability reasons.
          </p>
          <p>
            Default value: <code class="literal">info</code>.
          </p>
        </dd>
      
      
        <dt id="log_debug"><code class="option">log_debug</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#log_debug">#</a></dt>
        <dd>
          <p>
            Debug logging obviously creates a lot of log noise, so should only be done to diagnose problems.
          </p>
          <p>
              Deprecated. Use <code class="option">log_level</code> instead.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="log_subscriptions"><code class="option">log_subscriptions</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#log_subscriptions">#</a></dt>
        <dd>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="allow_unsafe_clientid_chars"><code class="option">allow_unsafe_clientid_chars</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#allow_unsafe_clientid_chars">#</a></dt>
        <dd>
          <p>
            If you have topics with client IDs in it, people can possibly manipulate your ACL checking by saying their client ID is 'John+foobar'. Audit your security before you allow this.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="allow_unsafe_username_chars"><code class="option">allow_unsafe_username_chars</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#allow_unsafe_username_chars">#</a></dt>
        <dd>
          <p>
            If you have topics with usernames in it, people can possibly manipulate your ACL checking by saying their username is 'John+foobar'. Audit your security before you allow this.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="max_packet_size"><code class="option">max_packet_size</code> <code class="replaceable">bytes</code><a class="hash-anchor" href="#max_packet_size">#</a></dt>
        <dd>
          <p>
            MQTT packets have a maximum size of about 256 MB. This memory will (temporarily) be allocated upon arrival of such packets, so there may be cause to set it lower.
          </p>
          <p>
            This option works in conjunction with <code class="option">client_max_write_buffer_size</code> to limit memory use.
          </p>
          <p>
            Default value: <code class="literal">268435461</code>
          </p>
        </dd>
      
      
        <dt id="client_max_write_buffer_size"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.4.4">≥ v1.4.4</div><code class="option">client_max_write_buffer_size</code> <code class="replaceable">bytes</code><a class="hash-anchor" href="#client_max_write_buffer_size">#</a></dt>
        <dd>
          <p>
            The client's write buffer is where packets are stored before the event loop has the chance to flush them out. Any time a client's connection is bad and bytes can't be flushed, this buffer fills. So, there's good reason to limit this to something sensible. A good indication is your average packet size (or better yet, a configured <code class="option">max_packet_size</code>) multiplied by the amount of packets you want to be able to buffer.
          </p>
          <p>
            Despite the name, this settings also control the read buffer's maximum size. Having a bigger read buffer may be necessary when you know your clients receive many packets.
          </p>
          <p>
            Note that it's an approximate value and not a hard limit. Buffer sizes only grow by powers of two, and buffers are always allowed to grow to make place for ping packets. Additionally, upon arrival of large packets (up to <code class="option">max_packet_size</code> bytes), room will be made up to twice their size. So, you may also want to reduce <code class="option">max_packet_size</code> from the default.
          </p>
          <p>
            Default value is <code class="literal">1048576</code> (1 MB)
          </p>
        </dd>
      
      
        <dt id="client_initial_buffer_size"><code class="option">client_initial_buffer_size</code> <code class="replaceable">bytes</code><a class="hash-anchor" href="#client_initial_buffer_size">#</a></dt>
        <dd>
          <p>
            The buffers for reading and writing, also for websockets when relevant, start out with a particular size and double when they need to grow. If you know your clients send bulks of a particular size, it helps to set this to match, to avoid constant memory reallocation. The default value is set conservatively, for scenario's with millions of clients.
          </p>
          <p>
            After buffers have grown, they are eventually reset to their original size when possible.
          </p>
          <p>
            Also see <code class="option">client_max_write_buffer_size</code> and <code class="option">max_packet_size</code>.
          </p>
          <p>
            Value must be a power of two.
          </p>
          <p>
            Default value: <code class="literal">1024</code>
          </p>
        </dd>
      
      
        <dt id="mosquitto_password_file"><code class="option">mosquitto_password_file</code> <code class="filename">/foo/bar/mosquitto_password_file</code><a class="hash-anchor" href="#mosquitto_password_file">#</a></dt>
        <dd>
          <p>
            File with usernames and hashed+salted passwords as generated by Mosquitto's <code class="command">mosquitto_passwd</code>.
          </p>
          <p>
            Mosquitto up to version 1.6 uses the sha512 algorithm. Newer version use sha512-pbkdf2. Both are supported.
          </p>
        </dd>
      
      
        <dt id="mosquitto_acl_file"><code class="option">mosquitto_acl_file</code> <code class="filename">/foo/bar/mosquitto_acl_file</code><a class="hash-anchor" href="#mosquitto_acl_file">#</a></dt>
        <dd>
          <p>
            ACL (access control lists) for users, anonymous users and patterns expandable with %u (username) and %c (clientid). Format is Mosquitto's acl_file.
          </p>
        </dd>
      
      
        <dt id="allow_anonymous"><code class="option">allow_anonymous</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#allow_anonymous">#</a></dt>
        <dd>
          <p>
              This option can be overriden on a per-listener basis; see <a href="#listen__allow_anonymous"><code class="option">listener.allow_anonymous</code></a>.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="zero_byte_username_is_anonymous"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.11.0">≥ v1.11.0</div><code class="option">zero_byte_username_is_anonymous</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#zero_byte_username_is_anonymous">#</a></dt>
        <dd>
          <p>
            The proper way to signal an anonymous client is by setting the 'username present' flag in the CONNECT packet to 0, which in MQTT3 also demands the absence of a password. However, there are also clients out there that set the 'username present' flag to 1 and then give an empty username. This is an undesirable situation, because it means there are two ways to identify an anonymous client.
          </p>

          <p>
            Anonymous clients are not authenticated against a loaded plugin when <code class="option">allow_anonymous</code> is true. With this option enabled, that means users with empty string as usernames also aren't.
          </p>

          <p>
            With this option disabled, clients connecting with an empty username will be reject with 'bad username or password' as MQTT error code.
          </p>

          <p>
            The default is to be unambigious, but this can be overridden with this option.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="rlimit_nofile"><code class="option">rlimit_nofile</code> <code class="replaceable">number</code><a class="hash-anchor" href="#rlimit_nofile">#</a></dt>
        <dd>
          <p>
            The general Linux default of <code class="literal">1024</code> can be overridden. Note: <code class="systemitem daemon">systemd</code> blocks you from setting it, so it needs to be set on the unit. The default systemd unit file sets <code class="option">LimitNOFILE=infinity</code>. You may also need to set <code class="option">sysctl -w fs.file-max=10000000</code>
          </p>
          <p>
            Default value: <code class="literal">1000000</code>
          </p>
        </dd>
      
      
        <dt id="expire_sessions_after_seconds"><code class="option">expire_sessions_after_seconds</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#expire_sessions_after_seconds">#</a></dt>
        <dd>
          <p>
            Expire sessions after this time. Setting to 0 disables it and is (MQTT3) standard-compliant. But, existing sessions cause load on the server (because they cost memory and are still subscribers), so keeping sessions after any client that connects with a random ID doesn't make sense.
          </p>
          <p>
            Default value: <code class="literal">1209600</code>
          </p>
        </dd>
      
      
        <dt id="quiet"><code class="option">quiet</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#quiet">#</a></dt>
        <dd>
          <p>
            Don't log LOG_INFO and LOG_NOTICE. This is useful when you have a lot of foot traffic, because otherwise the log gets filled with connect/disconnect notices.
          </p>
          <p>
              Deprecated. Use <code class="option">log_level</code> instead.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      
      
        <dt id="storage_dir"><code class="option">storage_dir</code> <code class="filename">/path/to/dir</code><a class="hash-anchor" href="#storage_dir">#</a></dt>
        <dd>
          <p>
            Location to store sessions, subscriptions and retained messages. Not specifying this will turn off persistence.
          </p>
        </dd>
      
      
        <dt id="save_state_interval"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.15.1">≥ v1.15.1</div><code class="option">save_state_interval</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#save_state_interval">#</a></dt>
        <dd>
          <p>
            The interval at which the state is saved, if enabled with <code class="option">storage_dir</code>.
          </p>
          <p>
            This setting is also applied on reload.
          </p>
          <p>
            Default: 3623
          </p>
        </dd>
      
      
        <dt id="max_qos_msg_pending_per_client"><code class="option">max_qos_msg_pending_per_client</code> <code class="replaceable">number</code></dt>
        <dt id="max_qos_bytes_pending_per_client"><code class="option">max_qos_bytes_pending_per_client</code> <code class="replaceable">bytes</code><a class="hash-anchor" href="#max_qos_bytes_pending_per_client">#</a></dt>
        <dd>
          <p>
            There is a limit to how many QoS packets can be stored in a session, so you can define a maximum amount of messages and bytes. If any of these is exceeded, the packet is dropped.
          </p>
          <p>
            Note that changing <code class="option">max_qos_msg_pending_per_client</code> only takes effect for new clients (also when picking up existing sessions). This is largely due to it being part of the MQTT5 connection handshake and is supposed to be adhered to.
          </p>
          <p>
            Defaults:
          </p>
          <ul>
            <li>
              <p>max_qos_msg_pending_per_client 512</p>
            </li>
            <li>
              <p>max_qos_bytes_pending_per_client 65536</p>
            </li>
          </ul>
        </dd>
      
      
        <dt id="max_incoming_topic_alias_value"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.4.2">≥ v1.4.2</div><code class="option">max_incoming_topic_alias_value</code> <code class="replaceable">number</code><a class="hash-anchor" href="#max_incoming_topic_alias_value">#</a></dt>
        <dd>
          <p>
            Is communicated towards MQTT5 clients. It is then up to them to decide to set them or not.
          </p>
          <p>
            Changing this setting and reloading the config only has effect on new clients, because existing clients would otherwise exceed the limit they think applies.
          </p>
          <p>
            Default value: <code class="literal">65535</code>
          </p>
        </dd>
      
      
        <dt id="max_outgoing_topic_alias_value"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.4.2">≥ v1.4.2</div><code class="option">max_outgoing_topic_alias_value</code> <code class="replaceable">number</code><a class="hash-anchor" href="#max_outgoing_topic_alias_value">#</a></dt>
        <dd>
          <p>
            FlashMQ will make this many aliases per MQTT5 client, if they ask for aliases (with the connect property <code class="option">TopicAliasMaximum</code>).
          </p>
          <p>
            Default value: <code class="literal">65535</code>
          </p>
        </dd>
      

      
        <dt id="thread_count"><code class="option">thread_count</code> <code class="replaceable">number</code><a class="hash-anchor" href="#thread_count">#</a></dt>
        <dd>
          <p>
            If you want to have a different amount of worker threads then CPUs, you can set this value. Typically you don't need to set this.
          </p>
          <p>
            Default value: <code class="filename">auto-detect</code>
          </p>
        </dd>
      

      
        <dt id="wills_enabled"><code class="option">wills_enabled</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#wills_enabled">#</a></dt>
        <dd>
          <p>
            When disabled, the server will not set last will and testament specified by connecting clients.
          </p>
          <p>
            Default value: <code class="filename">true</code>
          </p>
        </dd>
      

      
        <dt id="retained_messages_mode"><code class="option">retained_messages_mode</code> <code class="replaceable">enabled</code>|<code class="replaceable">enabled_without_persistence</code>|<code class="replaceable">downgrade</code>|<code class="replaceable">drop</code>|<code class="replaceable">disconnect_with_error</code><a class="hash-anchor" href="#retained_messages_mode">#</a></dt>
        <dd>
          <p>
            Retained messages can be a strain on the server you may not need. You can set various ways of dealing with them:
          </p>
          
          <p>
            <code class="filename">enabled</code>. This is normal operation.
          </p>
          <p data-since-flashmq-version="1.15.1">
            <code class="filename">enabled_without_persistence</code>. Like 'normal', except it won't store them to disk if <code class="option">storage_dir</code> is defined.
          </p>
          <p data-since-flashmq-version="1.16.0">
            <code class="filename">enabled_without_retaining</code>. This somewhat counter-intuitive sounding mode is like <code class="option">downgrade</code>, except that the 'retain' flag is not removed. This allows MQTT5 subscribers that subscribe with 'retain as published' to see which messages were originally sent as retained. It's just that FlashMQ won't retain them.
          </p>
          <p>
            <code class="filename">downgrade</code>. The retain flag is removed and treated like a normal publish.
          </p>
          <p>
            <code class="filename">drop</code>. Messages with retain set are dropped.
          </p>
          <p>
            <code class="filename">disconnect_with_error</code>. Disconnect clients who try to set them.
          </p>
          <p>
            Default value: <code class="filename">enabled</code>
          </p>
        </dd>
      

      
        <dt id="expire_retained_messages_after_seconds"><code class="option">expire_retained_messages_after_seconds</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#expire_retained_messages_after_seconds">#</a></dt>
        <dd>
          <p>
            Use this to limit the life time of retained messages. Without this, the amount of retained messages may never decrease.
          </p>
          <p>
            Default value: <code class="filename">4294967295</code>
          </p>
        </dd>
      

      
        <dt id="retained_messages_delivery_limit"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.6.7">≥ v1.6.7</div><code class="option">retained_messages_delivery_limit</code> <code class="replaceable">number</code><a class="hash-anchor" href="#retained_messages_delivery_limit">#</a></dt>
        <dd>
          <p>
            Deprecated.
          </p>
        </dd>
      

      
        <dt id="retained_messages_node_limit"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.8.4">≥ v1.8.4</div><code class="option">retained_messages_node_limit</code> <code class="replaceable">number</code><a class="hash-anchor" href="#retained_messages_node_limit">#</a></dt>
        <dd>
          <p>
            When clients place a subscription, they will get the retained messages matching that subscription. Even though traversing the retained message tree is deprioritized in favor of other traffic, it will still cause CPU load until it's done. If you have a tree with millions of nodes and clients subscribe to <code class="literal">#</code>, this is potentially unwanted. You can use this setting to limit how many nodes of the retrained tree are traversed.
          </p>
          <p>
            Note that the topic <code class="literal">one/two/three</code> is three nodes, and each node doesn't necessarilly need to contain a message.
          </p>
          <p>
            Default value: <code class="filename">4294967295</code>
          </p>
        </dd>
      

      
        <dt id="set_retained_message_defer_timeout"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.14.0">≥ v1.14.0</div><code class="option">set_retained_message_defer_timeout</code> <code class="replaceable">milliseconds</code><a class="hash-anchor" href="#set_retained_message_defer_timeout">#</a></dt>
        <dd>
          <p>
            The time after which FlashMQ will fall back to (b)locking vs queued mode for setting retained messages. 0, the default, disables queued mode altogether. It's disabled by default because it can incur some extra CPU and memory overhead.
          </p>
          <p>
            Each retained message lives in a node in a tree. The topic 'one/two/three' is three nodes. When a node in that tree does not exist yet, it needs to be created. This requires a write lock on the tree. At this point, other threads reading from or writing to the retained message tree need to wait. This can cause a compounding blocking effect, especially if many threads do it at once.
          </p>
          <p>
            This feature is to favor server responsiveness vs the speed at which retained messages become available in the server. It is primarily useful for when you have a lot of retained messages on different/changing topics. If at first a retained message can't be set, the action to do so will be retried in the event loop, asynchronously.
          </p>
          <p>
            This setting determines the maximum amount of time to defer setting a retained message, after which it will fall back to using locks.
          </p>
          <p>
            Also see <code class="option">set_retained_message_defer_timeout_spread</code>
          </p>
          <p>
            Default value: <code class="filename">0</code>
          </p>
        </dd>
      

      
        <dt id="set_retained_message_defer_timeout_spread"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.14.0">≥ v1.14.0</div><code class="option">set_retained_message_defer_timeout_spread</code> <code class="replaceable">milliseconds</code><a class="hash-anchor" href="#set_retained_message_defer_timeout_spread">#</a></dt>
        <dd>
          <p>
            For <code class="option">set_retained_message_defer_timeout</code>, the amount of random spread between 0 and this value for the timeout. This spreads out locking over time, reducing contention.
          </p>
          <p>
            Default value: <code class="filename">1000</code>
          </p>
        </dd>
      

      
        <dt id="retained_message_node_lifetime"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.14.0">≥ v1.14.0</div><code class="option">retained_message_node_lifetime</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#retained_message_node_lifetime">#</a></dt>
        <dd>
          <p>
            The grace period after which a retained message node is eligible for deletion. The topic 'one/two/three' is three nodes, and if that topic had a message, it would be contained in 'three'.
          </p>
          <p>
            FlashMQ will periodically clear out retained message nodes that have no message anymore. This is required to save memory. But, when you receive retained messages on the same topics repeatedly, it may be beneficial to keep the nodes around, to avoid the need for locks to recreate them. If you know that retained messages come and go within a certain period, it's benificial to set this value so that no unnecessary node destruction and creation takes place.
          </p>
          <p>
            Default value: <code class="filename">0</code>
          </p>
        </dd>
      

      
        <dt id="subscription_node_lifetime"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.15.1">≥ v1.15.1</div><code class="option">subscription_node_lifetime</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#subscription_node_lifetime">#</a></dt>
        <dd>
          <p>
            The grace period after which a subscription node is eligible for deletion. The subscription 'one/two/three' is three nodes.
          </p>
          <p>
            FlashMQ will periodically clear our nodes in the subscription tree that have no entries anymore. This is required to save memory. But, when clients place the same subscriptions repeatedly, it may be beneficial to keep the nodes around, to avoid the need for locks to recreate them. If you know that certain subscription patterns come and go within a certain period, it's benificial to set this value so that no unnecessary node destruction and creation takes place.
          </p>
          <p>
            Default value: <code class="filename">3600</code>
          </p>
        </dd>
      

      
        <dt id="websocket_set_real_ip_from"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.2.0">≥ v1.2.0</div><code class="option">websocket_set_real_ip_from</code> <code class="replaceable">inet4_address</code>|<code class="replaceable">inet6_address</code><a class="hash-anchor" href="#websocket_set_real_ip_from">#</a></dt>
        <dd>
          <p>
              HTTP proxies in front of the websocket listeners can set the <code class="replaceable">X-Real-IP</code> header to identify the original connecting client. With <code class="option">websocket_set_real_ip_from</code> you can mark IP networks as trusted. By default, clients are not trusted, to avoid spoofing.
          </p>
          <p>
              You can repeat the option to allow for multiple addresses. Valid notations are <code class="replaceable">1.2.3.4</code>, <code class="replaceable">1.2.3.4/16</code>, <code class="replaceable">1.2.0.0/16</code>, <code class="replaceable">2a01:1337::1</code>, <code class="replaceable">2a01:1337::1/64</code>, etc.
          </p>
          <p>
              The header <code class="replaceable">X-Forwarded-For</code> is not used, because that's designed to contain a list of addresses, if applicable.
          </p>
          <p>
            As a side note about using a proxy on your listener; you can only have an absolute max of 65535 connections to an IP+port combination (and the practical limit is lower). If you need more, you have to set up multiple listeners. This can be multiple IP addresses, or simply multiple ports.
          </p>
        </dd>
      

      
        <dt id="shared_subscription_targeting"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.2.0">≥ v1.2.0</div><code class="option">shared_subscription_targeting</code> <code class="replaceable">round_robin</code>|<code class="replaceable">sender_hash</code>|<code class="replaceable">first</code><a class="hash-anchor" href="#shared_subscription_targeting">#</a></dt>
        <dd>
          <p>
            When having multiple subscribers on a shared subscription (like '$share/myshare/jane/doe'), select how the messages should be distributed over the subscribers.
          </p>
          <p>
            <code class="replaceable">round_robin</code>. Select the next subscriber for each message. There is still some amount of randomness to it because the counter for this is not thread safe. Using an atomic/mutexed counter for it would just be too slow to justify.
          </p>
          <p>
            <code class="replaceable">sender_hash</code>. Selects a receiver deterministically based on the hash of the client ID of the sender. The selected subscriber will depend on how many subscribers there are, so if some disconnect, the distribution will change. Moreover, the selection may also change when FlashMQ cleans up empty spaces in the list of shared subscribers.
          </p>
          <p>
            <code class="replaceable">first</code>. Selects the first subscriber in the list. This mode can be useful for fallback. When one client disappears, the other will seamlessly take over.
          </p>
          <p>
            Default: <code class="replaceable">round_robin</code>
          </p>
        </dd>
      

      
        <dt id="minimum_wildcard_subscription_depth"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.9.0">≥ v1.9.0</div><code class="option">minimum_wildcard_subscription_depth</code> <code class="replaceable">number</code><a class="hash-anchor" href="#minimum_wildcard_subscription_depth">#</a></dt>
        <dd>
          <p>
            Defines the minimum level of the first wildcard topic filter (<code class="option">#</code> and <code class="option">+</code>). In a topic filter like <code class="option">sensors/temperature/#</code>, that is 2. If you specify 2, a subscription to <code class="option">sensors/#</code> will be denied. Remember that only MQTT 3.1.1 and newer actually notify the client of the denial in the sub-ack packet.
          </p>
          <p>
            The reason you may want to limit it, is performance. If you have a base message load of 100,000 messages per second, each client subscribing to <code class="option">#</code> causes that many permission checks per second. If you have 100 clients doing that, there will be 10 million permission checks per second.
          </p>
          <p>
            Default: <code class="replaceable">0</code>
          </p>
        </dd>
      

      
        <dt id="wildcard_subscription_deny_mode"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.9.0">≥ v1.9.0</div><code class="option">wildcard_subscription_deny_mode</code> <code class="replaceable">deny_all</code>|<code class="replaceable">deny_retained_only</code><a class="hash-anchor" href="#wildcard_subscription_deny_mode">#</a></dt>
        <dd>
          <p>
            For <code class="option">minimum_wildcard_subscription_depth</code>, specify what you want to deny. Trying to give a client all retained messages can cause quite some load, so only denying the retained messages upon receiving a broad wildcard subscription can be useful if you have a low enough general message volume, but a high number of retained messages. 
          </p>
          <p>
            Default: <code class="literal">deny_all</code>
          </p>
        </dd>
      

      
        <dt id="overload_mode"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.12.0">≥ v1.12.0</div><code class="option">overload_mode</code> <code class="replaceable">log</code>|<code class="replaceable">close_new_clients</code><a class="hash-anchor" href="#overload_mode">#</a></dt>
        <dd>
          <p>
            Define the action to perform when the value defined with <code class="option">max_event_loop_drift</code> is exceeded.
          </p>
          <p>
            When a server is (re)started, and hundreds of thousands of clients connect, the SSL handshaking and authenticating can be so heavy that it doesn't get to clients in time. They will then reconnect and try again, and get stuck in a loop. This option is to mitigate that. With <code class="literal">close_new_clients</code>, new clients will be closed immediately after connecting while the server is overloaded. This will allow the worker threads to process the new clients in a controlled manner.
          </p>
          <p>
              For really large deployments, this can be augmented with extra rate limiting in iptables, or other firewalls. A stateless method is preferred, like: <code class="literal">iptables -I INPUT -p tcp -m multiport --dports 8883,1883 --syn -m hashlimit --hashlimit-name newmqttconns --hashlimit-above 10000/second --hashlimit-burst 15000 -j DROP</code>
          </p>
          <p>
            The current default is <code class="literal">log</code>, but that will likely change in the future.
          </p>
          <p>
            Default: <code class="literal">log</code>
          </p>
        </dd>
      

      
        <dt id="max_event_loop_drift"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.12.0">≥ v1.12.0</div><code class="option">max_event_loop_drift</code> <code class="replaceable">milliseconds</code><a class="hash-anchor" href="#max_event_loop_drift">#</a></dt>
        <dd>
          <p>
            For <code class="option">overload_mode</code>, the maximum permissible thread drift before the overload action is taken.
          </p>
          <p>
            The drift values considered are those of the main loop, in which clients are accepted, and the median of all worker threads.
          </p>
          <p>
            Default: <code class="literal">2000</code>
          </p>
        </dd>
      

      
        <dt id="include_dir"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">include_dir</code> <code class="replaceable">/path/to/dir</code><a class="hash-anchor" href="#include_dir">#</a></dt>
        <dd>
          <p>
            Load *.conf files from the specified directory, to merge with the main configuration file.
          </p>
          <p>
            An error is generated when the directory is not there. This is to protect against running incorrect configurations by accident, when the dir has been renamed, for example.
          </p>
        </dd>
      

      
        <dt id="subscription_identifiers_enabled"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.18.0">≥ v1.18.0</div><code class="option">subscription_identifiers_enabled</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#subscription_identifiers_enabled">#</a></dt>
        <dd>
          <p>
            Subscription identifiers allow clients to see which subscription was responsible for a message. Publish messages will contain the identifier included in the original subscription.
          </p>
          <p>
            Enabling will prevent FlashMQ from using optimizations involving packet reuse, because the packets are unique per client when it contains a subscription identifier. Therefore you may want to assess the performance difference in high message volume deployments.
          </p>
          <p>
            As per the spec, clients sending subscription identifiers when the server reported the feature as unavailable will cause them to be disconnected. This has the side effect that changing this setting on a running server will disconnect clients when they send a subscription with an identifier in it. This was chosen as behavior over the alternatives, because of simplicity and operator control (otherwise it can't be turned off at all for existing clients).
          </p>
          <p>
            Default value: <code class="literal">true</code>
          </p>
        </dd>
      

    </dl>
  </section><section class="refsect1">
    <header><h2>Listen parameters</h2></header>
    <p>
       Listen parameters can only be used within <code class="literal">listen { }</code> blocks.
    </p>
    <dl>
      
        <dt id="port"><code class="option">port</code><a class="hash-anchor" href="#port">#</a></dt>
        <dd>
          <p>
            The default port depends on the <code class="option">protocol</code> parameter and whether or not <code class="option">fullchain</code> and <code class="option">privkey</code> parameters are supplied:
          </p>
          <ul>
            <li>
              <p>
                  For unencrypted MQTT, the default port is <code class="literal">1883</code>
              </p>
            </li>
            <li>
              <p>
                  For encrypted MQTT, the default port is <code class="literal">8883</code>
              </p>
            </li>
            <li>
              <p>
                  For plain HTTP websockets, the default port is <code class="literal">8080</code>
              </p>
            </li>
            <li>
              <p>
                  For encrypted HTTPS websockets, the default port is <code class="literal">4443</code>
              </p>
            </li>
          </ul>
        </dd>
      
      
        <dt id="protocol"><code class="option">protocol</code> <code class="replaceable">mqtt</code>|<code class="replaceable">websockets</code>|<code class="replaceable">acme</code><a class="hash-anchor" href="#protocol">#</a></dt>
        <dd>
          <p>
            This is a required parameter.
          </p>
          <p>
              For <code class="literal">acme</code>, see <a href="#listen__acme_redirect_url">acme_redirect_url</a>.
          </p>
        </dd>
      
      
        <dt id="inet_protocol"><code class="option">inet_protocol</code> <code class="replaceable">ip4_ip6</code>|<code class="replaceable">ip4</code>|<code class="replaceable">ip6</code>|<code class="replaceable">unix</code><a class="hash-anchor" href="#inet_protocol">#</a></dt>
        <dd>
          <p>
              When using <code class="literal">unix</code>, a <code class="option">unix_socket_path</code> is required.
          </p>
          <p>
            Default: <code class="literal">ip4_ip6</code>
          </p>
        </dd>
      
      
        <dt id="inet4_bind_address"><code class="option">inet4_bind_address</code> <code class="replaceable">inet4address</code><a class="hash-anchor" href="#inet4_bind_address">#</a></dt>
        <dd>
          <p>
            Default: 0.0.0.0
          </p>
        </dd>
      
      
        <dt id="inet6_bind_address"><code class="option">inet6_bind_address</code> <code class="replaceable">inet6address</code><a class="hash-anchor" href="#inet6_bind_address">#</a></dt>
        <dd>
          <p>
            Default: ::0
          </p>
        </dd>
      
      
        <dt id="unix_socket_path"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">unix_socket_path</code> <code class="replaceable">path</code><a class="hash-anchor" href="#unix_socket_path">#</a></dt>
        <dd>
          <p>
            When using <code class="literal">unix</code> for <code class="option">inet_protocol</code>, the file path of the socket.
          </p>
          <p>
            FlashMQ will remove pre-existing socket files if they already exist.
          </p>
        </dd>
      
      
        <dt id="unix_socket_user"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.23.0">≥ v1.23.0</div><code class="option">unix_socket_user</code> <code class="replaceable">user</code><a class="hash-anchor" href="#unix_socket_user">#</a></dt>
        <dd>
          <p>
            Use this to set the owner of the socket. It will always be attempted to set it, but a warning may be logged if not successful. Users may be specified as numeric or names.
          </p>
          <p>
            A config test will not verify the existence of users, for portability.
          </p>
        </dd>
      
      
        <dt id="unix_socket_group"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.23.0">≥ v1.23.0</div><code class="option">unix_socket_group</code> <code class="replaceable">group</code><a class="hash-anchor" href="#unix_socket_group">#</a></dt>
        <dd>
          <p>
            Use this to set the group of the socket. It will always be attempted to set it, but a warning may be logged if not successful. Groups may be specified as numeric or names.
          </p>
          <p>
            A config test will not verify the existence of groups, for portability.
          </p>
        </dd>
      
      
        <dt id="unix_socket_mode"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.23.0">≥ v1.23.0</div><code class="option">unix_socket_mode</code> <code class="replaceable">mode</code><a class="hash-anchor" href="#unix_socket_mode">#</a></dt>
        <dd>
          <p>
              Use this to specify the permission mode of the unix socket, like <code class="literal">600</code>.
          </p>
        </dd>
      
      
        <dt id="fullchain"><code class="option">fullchain</code> <code class="replaceable">/foobar/server.crt</code><a class="hash-anchor" href="#fullchain">#</a></dt>
        <dd>
          <p>
            Specifying a chain makes the listener SSL, and also requires the <code class="option">privkey</code> to be set.
          </p>
        </dd>
      
      
        <dt id="privkey"><code class="option">privkey</code> <code class="replaceable">/foobar/server.key</code><a class="hash-anchor" href="#privkey">#</a></dt>
        <dd>
          <p>
            Specifying a private key makes the listener SSL, and also requires the <code class="option">fullchain</code> to be set.
          </p>
        </dd>
      

      
        <dt id="listen__minimum_tls_version"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.20.0">≥ v1.20.0</div><code class="option">minimum_tls_version</code> <code class="replaceable">tlsv1.1</code>|<code class="replaceable">tlsv1.2</code>|<code class="replaceable">tlsv1.3</code><a class="hash-anchor" href="#listen__minimum_tls_version">#</a></dt>
        <dd>
          <p>
            Set minimum supported TLS version for TLS listeners. Note that setting this value low many not actually enable that protocol version if OpenSSL won't support it (anymore).
          </p>
          <p>
            The TLS version clients use is logged.
          </p>
          <p>
            Default: <code class="replaceable">tlsv1.1</code>
          </p>
        </dd>
      

      
        <dt id="client_verification_ca_file"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.8.0">≥ v1.8.0</div><code class="option">client_verification_ca_file</code> <code class="replaceable">/foobar/client_authority.crt</code><a class="hash-anchor" href="#client_verification_ca_file">#</a></dt>
        <dd>
          <p>
            Clients can be authenticated using X509 certificates, and the username taken from the CN (common name) field. Use this directive to specify the certificate authority you trust.
          </p>
          <p>
            Specifying this or <code class="option">client_verification_ca_dir</code> will require the listener to be TLS.
          </p>
        </dd>
      

      
        <dt id="client_verification_ca_dir"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.8.0">≥ v1.8.0</div><code class="option">client_verification_ca_dir</code> <code class="replaceable">/foobar/dir_with_certificates</code><a class="hash-anchor" href="#client_verification_ca_dir">#</a></dt>
        <dd>
          <p>
            Clients can be authenticated using X509 certificates, and the username taken from the CN (common name) field. Use this directive to specify the dir containing certificate authorities you trust.
          </p>
          <p>
              Note that the filename requirements are dictated by OpenSSL. Use the utility <code class="command">openssl rehash /path/to/dir</code>.
          </p>
          <p>
            Specifying this or <code class="option">client_verification_ca_file</code> will require the listener to be TLS.
          </p>
        </dd>
      

      
        <dt id="client_verification_still_do_authn"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.8.0">≥ v1.8.0</div><code class="option">client_verification_still_do_authn</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#client_verification_still_do_authn">#</a></dt>
        <dd>
          <p>
            When using X509 client authentication with <code class="option">client_verification_ca_file</code> or <code class="option">client_verification_ca_dir</code>, the username will not be checked with a user database or a plugin by default. Set this option to <code class="literal">true</code> to override that.
          </p>
        </dd>
      

      
        <dt id="listen__acme_redirect_url"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">acme_redirect_url</code> <code class="replaceable">http://example.com/</code><a class="hash-anchor" href="#listen__acme_redirect_url">#</a></dt>
        <dd>
          <p>
            This allows an ACME (automated certificate management environment) challenge to be redirected elsewhere. This allows decoupling of the certificate creation from the host(s) that run FlashMQ.
          </p>
          <p>
            This can either be configured on a dedicated listener with <code class="option">protocol</code> <code class="literal">acme</code>, or multiplexed on a non-SSL <code class="literal">mqtt</code> or <code class="literal">websockets</code> listener.
          </p>
        </dd>
      

      
        <dt id="listen__drop_on_absent_certificate"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">drop_on_absent_certificate</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#listen__drop_on_absent_certificate">#</a></dt>
        <dd>
          <p>
            When both <code class="option">privkey</code> and <code class="option">fullchain</code> are absent, don't create this listener. This can help in situations where you don't have the certificate and key yet, but you are expecting them.
          </p>
        </dd>
      

      
        <dt id="listen__only_allow_from"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">only_allow_from</code> <code class="replaceable">inet4_address</code>|<code class="replaceable">inet6_address</code><a class="hash-anchor" href="#listen__only_allow_from">#</a></dt>
        <dd>
          <p>
            When set, restricts the listener to the source address/network given.
          </p>
          <p>
            You can repeat the option to allow multiple addresses/networks. Valid notations are <code class="replaceable">1.2.3.4</code>, <code class="replaceable">1.2.3.4/16</code>, <code class="replaceable">1.2.0.0/16</code>, <code class="replaceable">2a01:1337::1</code>, <code class="replaceable">2a01:1337::1/64</code>, etc.
          </p>
        </dd>
      

      
        <dt id="listen__deny_from"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">deny_from</code> <code class="replaceable">inet4_address</code>|<code class="replaceable">inet6_address</code><a class="hash-anchor" href="#listen__deny_from">#</a></dt>
        <dd>
          <p>
            Block connections from this address or network.
          </p>
          <p>
            You can repeat the option multiple times. Valid notations are <code class="replaceable">1.2.3.4</code>, <code class="replaceable">1.2.3.4/16</code>, <code class="replaceable">1.2.0.0/16</code>, <code class="replaceable">2a01:1337::1</code>, <code class="replaceable">2a01:1337::1/64</code>, etc.
          </p>
        </dd>
      

      
        <dt id="listen__allow_anonymous"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.10.0">≥ v1.10.0</div><code class="option">allow_anonymous</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#listen__allow_anonymous">#</a></dt>
        <dd>
          <p>
            This allows you to override the <a href="#allow_anonymous">global <code class="option">allow_anonymous</code></a> setting on the listener level.
          </p>
        </dd>
      

      
        <dt id="listen__overload_mode"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.21.0">≥ v1.21.0</div><code class="option">overload_mode</code> <code class="replaceable">log</code>|<code class="replaceable">close_new_clients</code><a class="hash-anchor" href="#listen__overload_mode">#</a></dt>
        <dd>
          <p>
            This allows you to override the <a href="#overload_mode">global <code class="option">overload_mode</code></a> setting on the listener level.
          </p>
        </dd>
      

      
        <dt id="haproxy"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.1.0">≥ v1.1.0</div><code class="option">haproxy</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#haproxy">#</a></dt>
        <dd>
          <p>
            Setting the listener to haproxy makes it expect the PROXY protocol and set client source address to the original client. Make sure this listener is private / firewalled, otherwise anybody can set a different source address.
          </p>
          <p>
            Note that HAProxy's server health checks only started using the 'local' specifier as of version 2.4. This means earlier version will pretend to be a client and break the connection, causing log spam.
          </p>
          <p>
            As a side note about using a proxy on your listener; you can only have an absolute max of 65535 connections to an IP+port combination (and the practical limit is lower). If you need more, you have to set up multiple listeners. This can be multiple IP addresses, or simply multiple ports.
          </p>
          <p>
            See <a href="http://www.haproxy.org/">haproxy.org</a>.
          </p>
        </dd>
      

      
        <dt id="tcp_nodelay"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.13.0">≥ v1.13.0</div><code class="option">tcp_nodelay</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#tcp_nodelay">#</a></dt>
        <dd>
          <p>
            <code class="option">tcp_nodelay</code> will cause the <code class="literal">TCP_NODELAY</code> option to be set for the listener's socket(s), and therefore for all clients accepted on that listener.
          </p>
          <p>
            <code class="literal">TCP_NODELAY</code> is a OS TCP-layer option that will cause messages written by FlashMQ to the socket to be flushed immediately, without letting Nagle's algorithm (the default) collect small outgoing TCP packets into bigger packets.
          </p>
          <p>
            Foregoing Nagle's algorithm by setting <code class="option">tcp_nodelay</code> to <code class="replaceable">true</code> <em>may</em> decrease latency, at the likely cost of some network efficiency.
          </p>
          <p>
            Default: <code class="replaceable">false</code>
          </p>
        </dd>
      

      
        <dt id="listen__max_buffer_size"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">max_buffer_size</code> <code class="replaceable">number</code><a class="hash-anchor" href="#listen__max_buffer_size">#</a></dt>
        <dd>
          <p>
            Override the <code class="option">client_max_write_buffer_size</code> for this listener. This is especially useful when this listener is the receiving side of a bridge, because these clients will likely see more traffic.
          </p>
        </dd>
      

    </dl>
  </section><section class="refsect1" id="example_listeners">
    <header><h2>Example listeners<a class="hash-anchor" href="#example_listeners">#</a></h2></header>

    <pre class="literallayout monospaced">listen {
  protocol mqtt
  inet_protocol ip4_ip6
  inet4_bind_address 127.0.0.1
  inet6_bind_address ::1
  fullchain /foobar/server.crt
  privkey /foobar/server.key

  # default = 8883
  port 8883
}
listen {
  protocol mqtt
  fullchain /foobar/server.crt
  privkey /foobar/server.key
  client_verification_ca_file /foobar/client_authority.crt
  client_verification_still_do_authn false
}
listen {
  protocol mqtt
  inet_protocol ip4

  # default = 1883
  port 1883
}
listen {
  protocol websockets
  fullchain /foobar/server.crt
  privkey /foobar/server.key

  # default = 4443
  port 4443
}
listen {
  protocol websockets

  # default = 8080
  port 8080
}
listen {
  port 2883
  haproxy on
}</pre>
  </section><section class="refsect1" id="bridge" data-since-flashmq-version="1.7.0">
    <header><h2>Bridge configuration<a class="hash-anchor" href="#bridge">#</a></h2></header>
    <p>
      Bridges can be defined inside <code class="literal">bridge { }</code> blocks. A bridge is essentially just an outgoing connection to another server with loop-detection and retain flag relaying. It is not a form of clustering, although with careful design, it can be deployed to achieve some sort of load balancing. Note that normally (unless <code class="option">connection_count</code> is set) one bridge is one connection, and because FlashMQ's threading model is that clients are serviced by one selected thread only, a bridge has the potential to saturate a thread, if it's heavily loaded. You can improve that with <code class="option">connection_count</code>.
    </p>

    <p>
      Bridges are dynamically created, removed or changed upon config reload. When a bridge configuration changes, it will disconnect and reconnect.
    </p>

    <dl>
      
        <dt id="bridge__address"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">address</code> <code class="replaceable">address</code><a class="hash-anchor" href="#bridge__address">#</a></dt>
        <dd>
          <p>
              The DNS name, IPv4 or IPv6 address of the server you want to connect to.
          </p>
        </dd>
      

      
        <dt id="bridge__port"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">port</code> <code class="replaceable">number</code><a class="hash-anchor" href="#bridge__port">#</a></dt>
        <dd>
          <p>
            The default port depends on the <code class="option">tls</code> option, either 1883 or 8883.
          </p>
        </dd>
      

      
        <dt id="bridge__inet_protocol"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">inet_protocol</code> <code class="replaceable">ip4_ip6/ip4/ip6</code><a class="hash-anchor" href="#bridge__inet_protocol">#</a></dt>
        <dd>
          <p>
            Default: <code class="literal">ip4_ip6</code>
          </p>
        </dd>
      

      
        <dt id="bridge__tls"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">tls</code> <code class="replaceable">off/on/unverified</code><a class="hash-anchor" href="#bridge__tls">#</a></dt>
        <dd>
          <p>
            Set TLS mode. The value <code class="option">unverified</code> means the x509 chain is not verified.
          </p>
        </dd>
      

      
        <dt id="bridge__minimum_tls_version"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.20.0">≥ v1.20.0</div><code class="option">minimum_tls_version</code> <code class="replaceable">tlsv1.1</code>|<code class="replaceable">tlsv1.2</code>|<code class="replaceable">tlsv1.3</code><a class="hash-anchor" href="#bridge__minimum_tls_version">#</a></dt>
        <dd>
          <p>
            Set minimum supported TLS version the bridge will negotiate with the other side. Note that setting this value low many not actually enable that protocol version if OpenSSL won't support it (anymore).
          </p>
          <p>
            Default: <code class="replaceable">tlsv1.1</code>
          </p>
        </dd>
      

      
        <dt id="bridge__fullchain"><code class="option">fullchain</code> <code class="replaceable">/foobar/bridge.crt</code><a class="hash-anchor" href="#bridge__fullchain">#</a></dt>
        <dd>
          <p>
            With TLS enabled, specifying a chain makes the bridge connection authenticate to the remote broker using a public certificate, and also requires the <code class="option">privkey</code> to be set.
          </p>
        </dd>
      
      
      
        <dt id="bridge__privkey"><code class="option">privkey</code> <code class="replaceable">/foobar/bridge.key</code><a class="hash-anchor" href="#bridge__privkey">#</a></dt>
        <dd>
          <p>
            With TLS enabled, specifying a private key makes the bridge connection to remote broker use that key, and also requires the <code class="option">fullchain</code> to be set.
          </p>
        </dd>
      

      
        <dt id="bridge__ca_file"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">ca_file</code> <code class="replaceable">path</code><a class="hash-anchor" href="#bridge__ca_file">#</a></dt>
        <dd>
          <p>
            File to be used for x509 certificate chain validation.
          </p>
        </dd>
      

      
        <dt id="bridge__ca_dir"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">ca_dir</code> <code class="replaceable">path</code><a class="hash-anchor" href="#bridge__ca_dir">#</a></dt>
        <dd>
          <p>
            Directory containing certificates for x509 certificate chain validation.
          </p>
        </dd>
      

      
        <dt id="bridge__protocol_version"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">protocol_version</code> <code class="replaceable">mqtt3.1</code>|<code class="replaceable">mqtt3.1.1</code>|<code class="replaceable">mqtt5</code><a class="hash-anchor" href="#bridge__protocol_version">#</a></dt>
        <dd>
          <p>
            Default: <code class="literal">mqtt3.1.1</code>
          </p>
        </dd>
      

      
        <dt id="bridge__bridge_protocol_bit"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">bridge_protocol_bit</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#bridge__bridge_protocol_bit">#</a></dt>
        <dd>
          <p>
            An unofficial standard is to set the most significant bit of the protocol version byte to 1 to signal the connection is a bridge. This allows the other side to alter its behavior slightly. However, this is not always supported, so you can disable this if you get disconnected for reporting an invalid protocol version.
          </p>
          <p>
            This setting has no effect when using MQTT5, because the behavior it influences is done with subscription options.
          </p>
          <p>
            Default: <code class="literal">true</code>
          </p>
        </dd>
      

      
        <dt id="bridge__keepalive"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">keepalive</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#bridge__keepalive">#</a></dt>
        <dd>
          <p>
            The time between sending ping packets to the other side.
          </p>
          <p>
            Default: <code class="literal">60</code>
          </p>
        </dd>
      

      
        <dt id="bridge__clientid_prefix"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">clientid_prefix</code> <code class="replaceable">prefix</code><a class="hash-anchor" href="#bridge__clientid_prefix">#</a></dt>
        <dd>
          <p>
            The prefix of the randomly generated client ID. Client IDs cannot be explicitely set for security reasons. See <a href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/"><cite>Understanding clean session and clean start</cite></a>.
          </p>
          <p>
            Default: <code class="literal">fmqbridge</code>
          </p>
        </dd>
      

      
        <dt id="bridge__publish"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">publish</code> <code class="replaceable">filter</code> <code class="replaceable">qos</code><a class="hash-anchor" href="#bridge__publish">#</a></dt>
        <dd>
          <p>
              Messages matching this filter will be published to the other side. Examples: <code class="literal">#</code> or <code class="literal">sport/tennis/#</code>. This option can be repeated several times.
          </p>
          <p>
            The QoS value should be seen as the QoS value of the internal subscription causing outgoing messages. Messages that are relayed have this QoS level at most.
          </p>
          <p>
              Default: <code class="literal">0</code>
          </p>
        </dd>
      

      
        <dt id="bridge__subscribe"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">subscribe</code> <code class="replaceable">filter</code> <code class="replaceable">qos</code><a class="hash-anchor" href="#bridge__subscribe">#</a></dt>
        <dd>
          <p>
              Subscriptions for this filter is placed at the other side. Examples: <code class="literal">#</code> or <code class="literal">sport/tennis/#</code>. This option can be repeated several times.
          </p>
          <p>
            The QoS value is like any subscription at a server. Messages received by the other end will be given this QoS level at most.
          </p>
          <p>
              Default: <code class="literal">0</code>
          </p>
        </dd>
      

      
        <dt id="bridge__local_username"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">local_username</code> <code class="replaceable">username</code><a class="hash-anchor" href="#bridge__local_username">#</a></dt>
        <dd>
          <p>
            Username as seen by the local FlashMQ's plugin or ACL checks. This is not always necessary.
          </p>
        </dd>
      

      
        <dt id="bridge__remote_username"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">remote_username</code> <code class="replaceable">username</code><a class="hash-anchor" href="#bridge__remote_username">#</a></dt>
        <dd>
          <p>
            Username sent to the remote connection.
          </p>
        </dd>
      

      
        <dt id="bridge__remote_password"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">remote_password</code> <code class="replaceable">password</code><a class="hash-anchor" href="#bridge__remote_password">#</a></dt>
        <dd>
          <p>
            Password sent to the remote connection.
          </p>
        </dd>
      

      
        <dt id="bridge__remote_clean_start"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">remote_clean_start</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#bridge__remote_clean_start">#</a></dt>
        <dd>
          <p>
            In MQTT3, this means 'clean session', meaning the remote server removes any existing session with the same ID on (re)connect, and destroys it immediately on disconnect. If you want reuseable sessions that survive disconnects, set this to false. If you also want to pick up remote sessions on FlashMQ restart, set <code class="option">use_saved_clientid</code> to true.
          </p>
          <p>
            In MQTT5, this option only influences reconnection behavior. It essentially has no effect on the first connect, because the client ID is random and will always be new (except when you set <code class="option">use_saved_clientid</code>). But when set to true, any reconnects, which do use the already generated client ID, will destroy the session and in-flight messages will be lost.
          </p>
          <p>
            Also see <a href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">understanding clean session and clean start</a>.
          </p>
          <p>
            Default value: <code class="literal">true</code>
          </p>
        </dd>
      

      
        <dt id="bridge__local_clean_start"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">local_clean_start</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#bridge__local_clean_start">#</a></dt>
        <dd>
          <p>
              In MQTT3 mode, this means 'clean session' and means the session is removed upon disconnect. If you want to reuse sessions on reconnect, set this to false. Any new start of FlashMQ will give you a new client ID so will always be a fresh session, except if you set <code class="option">use_saved_clientid</code>.
          </p>
          <p>
            In MQTT5 mode, this only has effect on start, where any existing local session is removed if found. If you want the session to be removed immediately on disconnect, use <code class="option">local_session_expiry_interval</code> to 0.
          </p>
          <p>
            Also see <a href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">understanding clean session and clean start</a>.
          </p>
          <p>
            Default value: <code class="literal">true</code>
          </p>
        </dd>
      

      
        <dt id="bridge__remote_session_expiry_interval"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">remote_session_expiry_interval</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#bridge__remote_session_expiry_interval">#</a></dt>
        <dd>
          <p>
            Is only used in MQTT5 mode and determines the amount of seconds after which the session can be removed from the remote server.
          </p>
          <p>
            Default value: <code class="literal">0</code>
          </p>
        </dd>
      

      
        <dt id="bridge__local_session_expiry_interval"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">local_session_expiry_interval</code> <code class="replaceable">seconds</code><a class="hash-anchor" href="#bridge__local_session_expiry_interval">#</a></dt>
        <dd>
          <p>
              Determines when a local session without an active client will be removed, in both MQTT3 and MQTT5 mode. Note that in MQTT3 mode, the session is removed on disconnect when <code class="option">local_clean_start</code> is true.
          </p>
          <p>
            Default value: <code class="literal">0</code>
          </p>
        </dd>
      

      
        <dt id="bridge__remote_retain_available"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">remote_retain_available</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#bridge__remote_retain_available">#</a></dt>
        <dd>
          <p>
              MQTT5 allows a server to tell a client it doesn't support retained messages, or has it disabled. When using MQTT3, use this option to achieve the same.
          </p>
          <p>
              Messages will not be relayed with 'retained as published' and the retained messages that are normally sent on matching subscription, are not sent.
          </p>
          <p>
            Default value: <code class="literal">true</code>
          </p>
        </dd>
      

      
        <dt id="bridge__use_saved_clientid"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">use_saved_clientid</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#bridge__use_saved_clientid">#</a></dt>
        <dd>
          <p>
              When you want your bridges to resume local and remote sessions after restart, set this to true and set <code class="option">remote_clean_start</code>, <code class="option">local_clean_start</code>, <code class="option">remote_session_expiry_interval</code> and <code class="option">local_session_expiry_interval</code> accordingly. It only has effect when you have set a <code class="option">storage_dir</code>.
          </p>
          <p>
              It is important to fully understand the clean session / clean start behavior and the role the client ID plays in that. The primary goal of sessions is to survive link disconnects. Configuring a fixed client ID and use that each time an MQTT client starts, is often an anti-pattern, because most clients like actual IoT devices start fresh upon restart and don't store their sessions (with in-flight packets, etc) to disk. FlashMQ does store it on disk however, so it can be used legitamately. However, you can run into unexpected situations. For instance, you will get your existing subscriptions from the session too. So, if you remove a <code class="option">subscribe</code> line from your bridge configuration and restart, it will actually have no effect, because the server on the other side still has that subscription in the session.
          </p>
          <p>
            See <a href="https://www.flashmq.org/2022/11/26/understanding-clean-session-and-clean-start/">understanding clean session and clean start</a> for details.
          </p>
          <p>
            Default value: <code class="literal">false</code>
          </p>
        </dd>
      

      
        <dt id="bridge__max_outgoing_topic_aliases"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">max_outgoing_topic_aliases</code> <code class="replaceable">amount</code><a class="hash-anchor" href="#bridge__max_outgoing_topic_aliases">#</a></dt>
        <dd>
          <p>
            If you want FlashMQ to initiate topic aliases for this bridge, set this to a non-zero value. Note that it's floored to the value the remote side gives in the CONNACK packet, so it only works if the other side permits it.
          </p>
          <p>
              Default: <code class="literal">0</code>
          </p>
        </dd>
      

      
        <dt id="bridge__max_incoming_topic_aliases"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.7.0">≥ v1.7.0</div><code class="option">max_incoming_topic_aliases</code> <code class="replaceable">amount</code><a class="hash-anchor" href="#bridge__max_incoming_topic_aliases">#</a></dt>
        <dd>
          <p>
            If you want to accept topic aliases for this bridge, set this to a non-zero value. The value is set in the CONNECT packet to inform the remote side of the wish. It's not guaranteed that the other side will actually make aliases.
          </p>
          <p>
              Default: <code class="literal">0</code>
          </p>
        </dd>
      

      
        <dt id="bridge__tcp_nodelay"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.13.0">≥ v1.13.0</div><code class="option">tcp_nodelay</code> <code class="replaceable">true</code>|<code class="replaceable">false</code><a class="hash-anchor" href="#bridge__tcp_nodelay">#</a></dt>
        <dd>
          <p>
            <code class="option">tcp_nodelay</code> will cause the <code class="literal">TCP_NODELAY</code> option to be set for the client socket that is used to connect to the other end of the bridge.
          </p>
          <p>
            See the documentation for the <a href="#tcp_nodelay"><code class="option">tcp_nodelay</code></a> <em>listener</em> parameter for further elaboration.
          </p>
          <p>
            Default: <code class="replaceable">false</code>
          </p>
        </dd>
      

      
        <dt id="bridge__local_prefix"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.19.0">≥ v1.19.0</div><code class="option">local_prefix</code> <code class="replaceable">prefix</code><a class="hash-anchor" href="#bridge__local_prefix">#</a></dt>
        <dd>
          <p>
            Prefixes can be used to remap topics to and from the other end of the bridge. This makes it possible to insert a topic tree into the topic tree on another server, like a shared one.
          </p>

          <p>
            When a message comes in, the <code class="option">remote_prefix</code> is stripped from the topic, and the <code class="option">local_prefix</code> is added. The resulting topic is used for authorization 'write' checking.
          </p>

          <p>
            When a message goes out, the opposite happens: the <code class="option">local_prefix</code> is stripped and the <code class="option">remote_prefix</code> is added. However, this time, the original topic is used for authorization 'read' checking.
          </p>

          <p>
            The prefixes aren't applied to the <code class="option">subscribe</code> and <code class="option">publish</code> bridge options. You'll have to include the prefix in the subscriptions you configure. This is so that you can have multiple subscriptions to the other end, and only have the prefix applied to the relevant one(s). Messages that come in and go out that don't match the prefixes, are sent and received unchanged.
          </p>

          <p>
            The prefixes removal isn't done to topics that match the prefix exactly. This is to avoid <code class="literal">one/two/three/</code> (which has a legal empty string as last subtopic), becoming an empty string (which is illegal).
          </p>

          <p>
            If you define a prefix, they are required to end with a <code class="literal">/</code>. It's valid to have only a local or remote prefix.
          </p>
        </dd>
      

      
        <dt id="bridge__prefixes"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.19.0">≥ v1.19.0</div><code class="option">remote_prefix</code> <code class="replaceable">prefix</code><a class="hash-anchor" href="#bridge__prefixes">#</a></dt>
        <dd>
          <p>
              See <a href="#bridge__local_prefix"><code class="option">local_prefix</code></a>.
          </p>
        </dd>
      

      
        <dt id="bridge__connection_count"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">connection_count</code> <code class="replaceable">number</code>|<code class="replaceable">auto</code><a class="hash-anchor" href="#bridge__connection_count">#</a></dt>
        <dd>
          <p>
            Normally a bridge has one TCP connection to the other side. This means that dealing with bridge traffic is limited to one thread, which also applies to the remote side if that is also FlashMQ. With this option, you can make a bridge have multiple connections, and share the traffic load over them using MQTT5 'shared subscriptions'.
          </p>
          <p>
            When you specify a <code class="option">publish</code> or <code class="option">subscribe</code> path of <code class="literal">one/two/three</code>, the topic is adjusted to <code class="literal">$share/RANDOM/one/two/three</code> to create a shared subscription so that load is balanced. With FlashMQ, load balancing is especially important for the side processing publishes (because each received publish packet means subscribers have to be looked up, auth checked, etc).
          </p>
          <p>
            The <code class="option">shared_subscription_targeting</code> mode is automatically set to <code class="literal">sender_hash</code>. This is required to ensure sequential message relaying (to retain ordering), and it's also better in plugin code when messages from one source are kept to one thread, as it would be under normal circumstances.
          </p>
          <p>
            If FlashMQ is also on the receiving end of these load balanced connections, it uses an extra feature to group clients of one bridge together to enhance loop detection. Normally MQTT5 supports the 'no-local' subscription option for that, but the standard states that is not allowed for shared subscriptions. FlashMQ uses 'user properties' to communicate the group they belong to, so that we can still do this kind of loop detection. This allows you to specify overlapping paths in the <code class="option">subscribe</code> and <code class="option">publish</code> options of a bridge. Note that both ends should use FlashMQ version 1.22.0 or higher.
          </p>
          <p>
            When the target server indeed is also FlashMQ, it may be smart to create a dedicated listener, for several reasons. One is that incoming connections are given to threads in a sequential order per listener, this ensures the best spread over worker threads. It also allows you to set <code class="option">overload_mode</code>, <code class="option">max_buffer_size</code> and posssibly <code class="option">only_allow_from</code> and <code class="option">deny_from</code> differently for that listener.
          </p>
          <p>
              You can specify an amount of connections, or <code class="literal">auto</code> for one connection per CPU. FlashMQs load is mostly on the receiver of messages, so <code class="literal">auto</code> will likely be a good choice if most of your message load from the other side is incoming, vs outgoing. Otherwise it's best matched to the other side's number of CPUs.
          </p>
          <p>
            Default: <code class="replaceable">1</code>
          </p>
        </dd>
      

      
        <dt id="bridge__max_buffer_size"><div xmlns="http://docbook.org/ns/docbook" class="flashmq_version_requirement" data-since-flashmq-version="1.22.0">≥ v1.22.0</div><code class="option">max_buffer_size</code> <code class="replaceable">number</code><a class="hash-anchor" href="#bridge__max_buffer_size">#</a></dt>
        <dd>
          <p>
            Override the <code class="option">client_max_write_buffer_size</code> for this bridge. When <code class="option">connection_count</code> is used, this size applies to each connection individually.
          </p>
          <p>
            Bridges typically have more traffic than single clients, in which case it makes sense to increase this.
          </p>
        </dd>
      


    </dl>
  </section><section class="refsect1" id="example_bridge" data-since-flashmq-version="1.7.0">
    <header><h2>Example bridge<a class="hash-anchor" href="#example_bridge">#</a></h2></header>

    <pre class="literallayout monospaced">bridge {
    address demo.flashmq.org
    publish send/this
    subscribe receive/this
    local_username my_local_user
    remote_username my_remote_user
    remote_password my_remote_pass
    bridge_protocol_bit false
    tls on
    ca_file /path/to/ca.crt
}</pre>
  </section><section class="refsect1">
    <header><h2>Author</h2></header>
    <p>
        Wiebe Cazemier <a href="mailto:contact@flashmq.org">contact@flashmq.org</a>.
    </p>
  </section><section class="refsect1">
    <header><h2>See also</h2></header>

    <p>
      <span class="simplelist inline">
        <span class="member">
          <a href="https://www.flashmq.org/man/flashmq.1"><cite class="citerefentry"><span class="refentrytitle">flashmq</span><span class="manvolnum">(1)</span></cite></a>
        </span>
      </span>
    </p>
    <p>
      <a href="https://www.flashmq.org/">https://www.flashmq.org/</a>
    </p>
  </section><section class="refsect1" id="colophon" lang="en">
  <header><h2>Colophon<a class="hash-anchor" href="#colophon">#</a></h2></header>

  <p>
    The sources for the FlashMQ manual pages are maintained in <a href="https://tdg.docbook.org/tdg/5.2/">DocBook 5.2</a> XML files.  The transformation to the multiple destination file formats is done using a bunch of XSLT 1.0 sheets, contributed to this project by Rowan van der Molen.
  </p>
  
</section></article><script xmlns="http://docbook.org/ns/docbook" xmlns:dbk="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:semver="https://semver.org/spec/v2.0.0.html" xmlns:fmq="http://www.flashmq.org/man/">
function parseSemver(semver) {
  const re = /^(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  const { major, minor, patch, prerelease, buildmetadata } = re.exec(semver).groups;
  return {
    major: parseInt(major),
    minor: parseInt(minor),
    patch: parseInt(patch),
    prerelease: prerelease,
    buildmetadata: buildmetadata,
  };
}

function compareSemver(a, b) {
  const a_obj = parseSemver(a);
  const b_obj = parseSemver(b);

  if (a_obj.major < b_obj.major) return -1;
  if (a_obj.major > b_obj.major) return 1;
  if (a_obj.minor < b_obj.minor) return -1;
  if (a_obj.minor > b_obj.minor) return 1;
  if (a_obj.patch < b_obj.patch) return -1;
  if (a_obj.patch > b_obj.patch) return 1;
  if (a_obj.prerelease !== null && b_obj.prerelease === null) return -1;
  if (a_obj.prerelease === null && b_obj.prerelease !== null) return 1;
  // NOTE: prereleases are not taken into account and probably will never need to, because, though Wiebe
  //       may start to do prereleases, new options and option values will then almost certainly be bound
  //       to the main (major + minor + patch) version to which the prerelease identifiers are appended.

  return 0;
}

function applySelectedFlashmqVersion(selectElement) {
  console.assert(selectElement instanceof HTMLSelectElement);

  const selectedVersion = selectElement.selectedOptions[0].value;

  for (const el of document.querySelectorAll('[data-since-flashmq-version]')) {
    const contentAppliesSinceVersion = el.dataset.sinceFlashmqVersion;
    if (selectedVersion !== '' && compareSemver(contentAppliesSinceVersion, selectedVersion) > 0) {
      el.classList.add('incompatible-with-selected-flashmq-version');
      el.classList.remove('compatible-with-selected-flashmq-version');
    }
    else {
      el.classList.add('compatible-with-selected-flashmq-version');
      el.classList.remove('incompatible-with-selected-flashmq-version');
    }
  }

  const url = new URL(window.location.href);
  const searchParams = new URLSearchParams(url.search);
  if (selectedVersion === '') {
    searchParams.delete('v');
  }
  else {
    searchParams.set('v', selectedVersion);
  }
  url.search = searchParams.toString();
  history.pushState({}, '', url);
}

const selectFlashmqVersionElement = document.getElementById('select-flashmq-version');
selectFlashmqVersionElement.addEventListener('change', (e) => {
  applySelectedFlashmqVersion(e.target);
});

const url = new URL(window.location.href);
if (url.search) {
  if (url.searchParams.has('v')) {
    const versionFromUrl = url.searchParams.get('v');
    for (const opt of selectFlashmqVersionElement.options) {
      if (opt.value === versionFromUrl) {
        opt.selected = true;
      }
    }
  }
}

applySelectedFlashmqVersion(selectFlashmqVersionElement);
    </script></body></html>
